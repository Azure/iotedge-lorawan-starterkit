name: LoRa CI
on: # rebuild any PRs and main branch changes
  pull_request:
    branches:
      - master
      - dev
    paths-ignore:
      - 'Docs/**'
      - 'Arduino/**'
      - 'Samples/**'
  push:
    branches:
      - master
      - dev
  workflow_dispatch:
    inputs:
      RunTestsOnly:
        description: 'Run tests only'
        default: false   
      TestsToRun:
        default: '[\"SensorDecodingTest\",\"OTAAJoinTest\",\"ABPTest\",\"OTAATest\",\"MacTest\",\"ClassCTest\",\"C2DMessageTest\",\"MultiGatewayTest\"]'
        description: 'tests to run'
env:
  buildConfiguration: 'Release'
  AZURE_FUNCTIONAPP_NAME: loramoduleintegrationtest

jobs:
  env_var:
    name: Set environment variables
    runs-on: ubuntu-latest
    steps:
    - id: e2e_list_step
      name: Set E2E tests to run
      run: |
        if [ ${{ github.event_name }} == 'workflow_dispatch' ]; then
          echo "Set up for workflow dispatch"  
          echo "::set-output name=E2eTestsToRun::${{ github.event.inputs.TestsToRun }}"
        else
          echo "::set-output name=E2eTestsToRun::[\"SensorDecodingTest\",\"OTAAJoinTest\",\"ABPTest\",\"OTAATest\",\"MacTest\",\"ClassCTest\",\"C2DMessageTest\",\"MultiGatewayTest\"]" 
        fi

    - id: check-if-run
      name: Check if deploy on local ci
      if: github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'fullci' ) != true 
      run: |
        echo "::set-output name=StopFullCi::true"

    - name: Avoid concurrent run
      uses: softprops/turnstyle@v1
      with:
        poll-interval-seconds: 30
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    outputs:
      AZURE_FUNCTIONAPP_NAME: ${{ env.AZURE_FUNCTIONAPP_NAME }}
      RunTestsOnly: ${{ github.event.inputs.RunTestsOnly == 'true' || contains(github.event.client_payload.labels.*.name, 'RunTestsOnly') == true}}
      E2eTestsToRun: ${{ steps.e2e_list_step.outputs.E2eTestsToRun }}
      StopFullCi: ${{ steps.check-if-run.outputs.StopFullCi }}
  
  build_and_test:
    name: Build and Test Solution
    runs-on: ubuntu-latest
    needs: 
      - env_var
    if: needs.env_var.outputs.RunTestsOnly != 'true'
    steps:
    - uses: actions/checkout@v2
      name: Checkout current branch

    - name: .NET SDK Information
      run: dotnet --info

    # build LoRa Engine
    - name: Build LoRa Engine
      run: dotnet build --configuration ${{ env.buildConfiguration }} LoRaEngine/LoRaEngine.sln

    # build C# Samples/DecoderSample
    - name: Build C# Samples/DecoderSample
      run: dotnet build --configuration ${{ env.buildConfiguration }} Samples/DecoderSample 

    # build LoRa Simulator
    - name: Build LoRa Simulator
      run: dotnet build --configuration ${{ env.buildConfiguration }} LoRaEngine/modules/LoRaSimulator/LoRaSimulator.sln

    # Pull Redis Cache docker image
    - name: Pulling Redis Cache image
      run: docker pull redis:5.0.4-alpine

    # Run unit tests
    - name: Run unit tests
      run: |
        dotnet test --configuration ${{ env.buildConfiguration }} --logger trx -r Tests/TestResults/Unit \
          /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura \
          --filter 'FullyQualifiedName~LoRaWanTest|FullyQualifiedName~LoRaWan.NetworkServer.Test|FullyQualifiedName~LoraKeysManagerFacade.Test' \
          LoRaEngine
      
    # Upload test results as artifact
    - uses: actions/upload-artifact@v1
      if: success() || failure()
      with:
        name: unit-test-results
        path: Tests/TestResults/Unit

    - name: Upload to Codecov
      uses: codecov/codecov-action@v2

  check_if_deploy:
    needs: 
      - env_var
    runs-on: ubuntu-latest
    environment: CI
    if: needs.env_var.outputs.RunTestsOnly != 'true' && needs.env_var.outputs.StopFullCi  != 'true'
    name: Deploy this run on the CI environment
    steps:
    - run : echo "Deployment was authorized"

  # Build and deploy Facade Azure Function
  deploy_facade_function:
    needs: 
    - env_var
    - check_if_deploy
    name: Build and Deploy Facade Azure Function   
    runs-on: ubuntu-latest
    if: needs.env_var.outputs.RunTestsOnly != 'true'
    env:
      AZURE_FUNCTIONAPP_PACKAGE_PATH: 'LoRaEngine/LoraKeysManagerFacade/'

    steps:
    - uses: actions/checkout@v2
      name: Checkout current branch

    - name: 'Resolve Project Dependencies Using Dotnet'
      shell: bash
      run: |
        pushd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
        dotnet build --configuration ${{ env.buildConfiguration }} --output ./output
        popd

    - name: 'Run Azure Functions Action'
      uses: Azure/functions-action@v1
      id: fa
      with:
        app-name: ${{ env.AZURE_FUNCTIONAPP_NAME }}
        package: '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}output'
        publish-profile: ${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE }}

  # Deploy IoT Edge solution to ARM gateway
  deploy_arm_gw_iot_edge:
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix: 
        gateway: [ primary, secondary ]
        include:
          - gateway: primary
            architecture: arm32v7
          - gateway: secondary
            architecture: arm32v7
    needs: 
    - env_var
    - check_if_deploy
    if: needs.env_var.outputs.RunTestsOnly != 'true'
    env:
      CONTAINER_REGISTRY_ADDRESS: "loramoduleintegrationtest.azurecr.io"
      CONTAINER_REGISTRY_SERVER: "loramoduleintegrationtest.azurecr.io"
      CONTAINER_REGISTRY_USERNAME: "loramoduleintegrationtest"
      CONTAINER_REGISTRY_PASSWORD: ${{ secrets.ACR_CREDENTIALS }}
      IOTHUB_CONNECTION_STRING: ${{ secrets.IOTHUB_CONNECTION_STRING }}
      IOT_EDGE_DEPLOYMENT_ID: "citest${{ matrix.gateway }}"
      NET_SRV_LOG_LEVEL: 1
      NET_SRV_LOGTO_HUB: false
      NET_SRV_LOGTO_UDP: true
      NET_SRV_IOTEDGE_TIMEOUT: 0
      NET_SRV_LOG_TO_UDP_ADDRESS: "itestup"
      EDGEHUB_ROUTE: "FROM /* INTO $upstream"
      RESET_PIN: 7
      REGION: "EU"
      FACADE_SERVER_URL: "https://${{ needs.env_var.outputs.AZURE_FUNCTIONAPP_NAME }}.azurewebsites.net/api/"
      FACADE_AUTH_CODE: ${{ secrets.FUNCTION_AUTH_CODE }}
      EDGE_AGENT_VERSION: 1.2.2
      EDGE_HUB_VERSION: 1.2.2
      EDGEHUB_OPTIMIZEFORPERFORMANCE: false
      EDGEHUB_MQTTSETTINGS_ENABLED: false
      EDGEHUB_HTTPSETTINGS_ENABLED: false
      BUILD_BUILDID: ${{ github.run_id }}
      DEV_IMAGE_TAG: dev
      DEVICE_ID: ${{ matrix.gateway }}
      MASTER_IMAGE_TAG: master
    runs-on: ubuntu-latest
    name: Run IoT Edge Deployment on ARM gateway
    steps:  
      - uses: actions/checkout@v2
        name: Checkout current branch

      - run: |
          if [ ${{ github.ref	}} = "refs/heads/dev" ]; then
          echo "dev"  
          IMAGE_TAG="$DEV_IMAGE_TAG"
          elif [ ${{ github.ref	}} = "refs/heads/master" ]; then
          echo "master"
          IMAGE_TAG="$MASTER_IMAGE_TAG"
          elif [ ${{ github.event_name }} == "pull_request" ]; then
          echo "pull request"
          IMAGE_TAG="pr-${{ github.event.number}}"
          else
          echo "all others"
          IMAGE_TAG="custom-${GITHUB_REF##*/}"
          fi
          echo "Using image tag prefix $IMAGE_TAG"
          IMAGE_TAG="$IMAGE_TAG-${{ github.run_number }}"
          echo "Using image tag $IMAGE_TAG"
          echo "::set-env name=NET_SRV_VERSION::$IMAGE_TAG"
          echo "::set-env name=PKT_FWD_VERSION::$IMAGE_TAG"
        env: 
          ACTIONS_ALLOW_UNSECURE_COMMANDS: true

      - name: Iot Edge Push Solution
        uses: ./devops
        id: edgedev_push
        with:
          command: push
          folder_path: 'LoRaEngine'
          file_name: 'deployment.test.template.json'
          target_platform: ${{ matrix.architecture }}

      - name: Iot Edge Deploy
        uses: ./devops
        id: edgedev_deploy
        with:
          command: deploy
          folder_path: 'LoRaEngine'
          file_name: 'deployment.test.template.json'
          target_platform: ${{ matrix.architecture }}

      - name: Wait for IoT Edge Deployment
        run: |
          az extension add --name azure-iot   
          until `az iot edge deployment show-metric --deployment-id ${{ env.IOT_EDGE_DEPLOYMENT_ID }} --metric-id reportedSuccessfulCount --metric-type system --login '${{ secrets.IOTHUB_CONNECTION_STRING }}' | grep -q $DEVICE_ID`; do sleep 10 && echo wait; done
          
          # We add the 3 minutes sleep to let the container start up
          # TODO We might want to revisit this once there are some options to check that the network server started.
          sleep 3m

# Runs E2E tests in dedicated agent, while having modules deployed into PI (arm32v7)
  e2e_tests_job :
    name: Run E2E Tests 
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: 
        testsToRun: ${{ fromjson(needs.env_var.outputs.E2eTestsToRun) }}
    if: always() && (needs.env_var.outputs.RunTestsOnly == 'true' || (needs.deploy_arm_gw_iot_edge.result == 'success' && needs.deploy_facade_function.result == 'success' && needs.build_and_test.result == 'success')) 
    needs: 
      - deploy_arm_gw_iot_edge
      - deploy_facade_function
      - build_and_test
      - env_var
    runs-on: [ self-hosted, x64 ]
    timeout-minutes: 60
    env:      
      E2ETESTS_LeafDeviceSerialPort: '/dev/ttyACM0'
      E2ETESTS_IoTHubEventHubConsumerGroup: 'reserved_integrationtest_amd'
      E2ETESTS_LeafDeviceGatewayID: primary
      E2ETESTS_DevicePrefix: '01'
      E2ETESTS_EnsureHasEventDelayBetweenReadsInSeconds: 15
      E2ETESTS_EnsureHasEventMaximumTries: 5
      E2ETESTS_IoTHubConnectionString: ${{ secrets.IOTHUB_CONNECTION_STRING }}
      E2ETESTS_IoTHubEventHubConnectionString: ${{ secrets.IOTHUB_EVENT_HUB_CONNECTION_STRING }}
      E2ETESTS_FunctionAppCode: ${{ secrets.FUNCTION_AUTH_CODE }}
      E2ETESTS_FunctionAppBaseUrl: "https://${{ needs.env_var.outputs.AZURE_FUNCTIONAPP_NAME }}.azurewebsites.net/api/"

    steps:
    - uses: actions/checkout@v2
      if: contains(github.event.pull_request.labels.*.name, matrix.testsToRun ) != true 
      name: Checkout current branch

    - name: 'Configure E2E tests' 
      uses: cschleiden/replace-tokens@v1
      if: contains(github.event.pull_request.labels.*.name, matrix.testsToRun ) != true 
      with:
        files: '**/Tests/E2E/appsettings.json'
    
    # Builds and runs E2E tests
    - name: Build E2E tests
      if: contains(github.event.pull_request.labels.*.name, matrix.testsToRun ) != true 
      run: dotnet build --configuration ${{ env.buildConfiguration }} **/Tests/E2E/LoRaWan.Tests.E2E.csproj

    - name: Runs E2E tests ${{ matrix.testsToRun }}
      if: contains(github.event.pull_request.labels.*.name, matrix.testsToRun ) != true 
      id: e2e_tests_step
      run: |
        echo ${{ matrix.testsToRun }}
        dotnet test --logger trx --no-build --configuration ${{ env.buildConfiguration }} \
        -p:ParallelizeTestCollections=false -r Tests/TestResults/E2E/ --filter "${{ matrix.testsToRun }}" \
        **/Tests/E2E/LoRaWan.Tests.E2E.csproj
    
    # Upload test results as artifact
    - uses: actions/upload-artifact@v1
      if: (success() || failure()) && contains(github.event.pull_request.labels.*.name, matrix.testsToRun ) != true 
      with:
        name: e2e-test-results
        path: Tests/TestResults/E2E/

    - name: Add ${{ matrix.testsToRun }} Test Label
      uses: buildsville/add-remove-label@v1
      if: github.event_name == 'pull_request' && steps.e2e_tests_step.conclusion == 'Success' && contains(github.event.pull_request.labels.*.name, matrix.testsToRun ) != true 
      with:
        token: ${{secrets.GITHUB_TOKEN}}
        label: '${{ matrix.testsToRun }}'
        type: add


