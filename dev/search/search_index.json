{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Azure IoT Edge LoRaWAN Starter Kit The LoRaWAN starter kit is an OSS cross platform private network implementation of the LoRaWAN specification built for connectivity to Azure IoT Hub. It enables users to setup their own LoRaWAN network that can connect to LoRa based nodes (sensors) and send decoded message packets to Azure IoT Hub for cloud based processing, analytics and other workloads. Alternatively, it allows sending commands from the cloud to the end nodes. The goal of the the project is to provide guidance and a reference for Azure IoT Edge users to experiment with LoRaWAN technology. Features LoRaWAN 1.0.2 implementation (see LoRaWAN Specification Support for more details) Device and Gateway management done completely through Azure IoT Hub. Bi-directional communication between LoRa end devices and Azure cloud. Custom packet decoding framework. Identity Translation for LoRa devices with caching support. Partial Offline and Casually connected Gateways scenarios.* Easy deployment and setup using Azure ARM templates. Small to Midsize Scalability Tests. Simulator for development and testing without the need to own a Gateway. LoRaWAN Specification Support We plan to support the following key features of LoRaWAN 1.0.2 specification, however please note that not all of them are available as of today. Please refer to our release notes for more details on what is available. Current supported Specification: 1.0.2 . Support of Class A and C devices. Support of EU868 and US915 channel frequencies. Activation through ABP and OTAA . Confirmed and unconfirmed upstream messages. Confirmed and unconfirmed downstream messages. Multi-gateways. Message de-duplication. Support of MAC commands. ADR Support. Prerequisites The following should be completed before proceeding with the LoRaWAN starter kit development or deployment in your environment. You must have an Azure subscription. Get an Azure Free account to get started. We are based on Azure IoT Edge so it is important that you understand the concepts and deployment model for Azure IoT Edge. Refer to Azure IoT Edge documentation to see how it works. Understand how LoRa and LoRaWAN works. A great primer is available at the LoRa Alliance website . To test the solution on a device, you need to have a LoRaWAN Device Kit Gateway and a LoRa end node. We have some recommendations in the Tested Gateways section below. Getting Started We have a variety of ways you can get started with the kit, chose the appropriate documentation based on your persona and applicability. Setup a LoRaWAN Gateway : We provide an easy to use Azure ARM template and deployment guidance to get you quickly started with the LoRaWAN starter kit. Use the Quick Start to setup a LoRaWAN Gateway and connect to LoRA end nodes. Upgrade an existing installation : Refer to the upgrade guide for instructions and tips for a clean upgrade. Develop and debug the LoRaWAN starter kit : If you are a developer and want to contribute or customize the LoRaWAN starter kit, refer to our Developer Guidance for more details on how to build, test and deploy the kit in your dev environment. We also support a Enable a gateway or device to be compatible with the starter kit : We have developed the LoRaWAN starter kit agnostic of a device manufacturer implementation and focussed on the specifics on underlying architectures (arm, x86). However, we understand that device manufacturers can have specific requirements; these could be specific to a gateway and the basic station they use or to the LoRa nodes and the decoders the device may use. We have provided specific instructions on making these specialized hardware compatible with our kit. You can follow these instructions depending on your scenarios and also have your device gateway highlighted on our repo. Known Issues and Limitations Refer to Known Issues for known issues, gotchas and limitations. Tested Gateways Seeed Studio LoRa LoRaWAN Gateway - 868MHz Kit with Raspberry Pi 3 AAEON AIOT-ILRA01 LoRa\u00ae Certified Intel\u00ae Based Gateway and Network Server AAEON Indoor 4G LoRaWAN Edge Gateway & Network Server AAEON AIOT-IP6801 Multi radio Outdoor Industrial Edge Gateway MyPi Industrial IoT Integrator Board with RAK833-SPI mPCIe-LoRa-Concentrator Raspberry Pi 3 with IC880A RAK833-USB mPCIe-LoRa-Concentrator with Raspberry Pi 3","title":"Home"},{"location":"#azure-iot-edge-lorawan-starter-kit","text":"The LoRaWAN starter kit is an OSS cross platform private network implementation of the LoRaWAN specification built for connectivity to Azure IoT Hub. It enables users to setup their own LoRaWAN network that can connect to LoRa based nodes (sensors) and send decoded message packets to Azure IoT Hub for cloud based processing, analytics and other workloads. Alternatively, it allows sending commands from the cloud to the end nodes. The goal of the the project is to provide guidance and a reference for Azure IoT Edge users to experiment with LoRaWAN technology.","title":"Azure IoT Edge LoRaWAN Starter Kit"},{"location":"#features","text":"LoRaWAN 1.0.2 implementation (see LoRaWAN Specification Support for more details) Device and Gateway management done completely through Azure IoT Hub. Bi-directional communication between LoRa end devices and Azure cloud. Custom packet decoding framework. Identity Translation for LoRa devices with caching support. Partial Offline and Casually connected Gateways scenarios.* Easy deployment and setup using Azure ARM templates. Small to Midsize Scalability Tests. Simulator for development and testing without the need to own a Gateway.","title":"Features"},{"location":"#lorawan-specification-support","text":"We plan to support the following key features of LoRaWAN 1.0.2 specification, however please note that not all of them are available as of today. Please refer to our release notes for more details on what is available. Current supported Specification: 1.0.2 . Support of Class A and C devices. Support of EU868 and US915 channel frequencies. Activation through ABP and OTAA . Confirmed and unconfirmed upstream messages. Confirmed and unconfirmed downstream messages. Multi-gateways. Message de-duplication. Support of MAC commands. ADR Support.","title":"LoRaWAN Specification Support"},{"location":"#prerequisites","text":"The following should be completed before proceeding with the LoRaWAN starter kit development or deployment in your environment. You must have an Azure subscription. Get an Azure Free account to get started. We are based on Azure IoT Edge so it is important that you understand the concepts and deployment model for Azure IoT Edge. Refer to Azure IoT Edge documentation to see how it works. Understand how LoRa and LoRaWAN works. A great primer is available at the LoRa Alliance website . To test the solution on a device, you need to have a LoRaWAN Device Kit Gateway and a LoRa end node. We have some recommendations in the Tested Gateways section below.","title":"Prerequisites"},{"location":"#getting-started","text":"We have a variety of ways you can get started with the kit, chose the appropriate documentation based on your persona and applicability. Setup a LoRaWAN Gateway : We provide an easy to use Azure ARM template and deployment guidance to get you quickly started with the LoRaWAN starter kit. Use the Quick Start to setup a LoRaWAN Gateway and connect to LoRA end nodes. Upgrade an existing installation : Refer to the upgrade guide for instructions and tips for a clean upgrade. Develop and debug the LoRaWAN starter kit : If you are a developer and want to contribute or customize the LoRaWAN starter kit, refer to our Developer Guidance for more details on how to build, test and deploy the kit in your dev environment. We also support a Enable a gateway or device to be compatible with the starter kit : We have developed the LoRaWAN starter kit agnostic of a device manufacturer implementation and focussed on the specifics on underlying architectures (arm, x86). However, we understand that device manufacturers can have specific requirements; these could be specific to a gateway and the basic station they use or to the LoRa nodes and the decoders the device may use. We have provided specific instructions on making these specialized hardware compatible with our kit. You can follow these instructions depending on your scenarios and also have your device gateway highlighted on our repo.","title":"Getting Started"},{"location":"#known-issues-and-limitations","text":"Refer to Known Issues for known issues, gotchas and limitations.","title":"Known Issues and Limitations"},{"location":"#tested-gateways","text":"Seeed Studio LoRa LoRaWAN Gateway - 868MHz Kit with Raspberry Pi 3 AAEON AIOT-ILRA01 LoRa\u00ae Certified Intel\u00ae Based Gateway and Network Server AAEON Indoor 4G LoRaWAN Edge Gateway & Network Server AAEON AIOT-IP6801 Multi radio Outdoor Industrial Edge Gateway MyPi Industrial IoT Integrator Board with RAK833-SPI mPCIe-LoRa-Concentrator Raspberry Pi 3 with IC880A RAK833-USB mPCIe-LoRa-Concentrator with Raspberry Pi 3","title":"Tested Gateways"},{"location":"contributing/","text":"Contributing If you would like to contribute to the IoT Edge LoRaWAN Starter Kit source code, please base your own branch and pull request (PR) off our dev branch. Refer to the Dev Guide for development and debugging instructions.","title":"Contributing"},{"location":"contributing/#contributing","text":"If you would like to contribute to the IoT Edge LoRaWAN Starter Kit source code, please base your own branch and pull request (PR) off our dev branch. Refer to the Dev Guide for development and debugging instructions.","title":"Contributing"},{"location":"issues/","text":"Known Issues and Limitations Reporting Security Issues Security issues and bugs should be reported privately, via email, to the Microsoft Security Response Center (MSRC) at secure@microsoft.com . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Further information, including the MSRC PGP key, can be found in the Security TechCenter . Limitations Tested only for EU868 and US915 frequency IoT Edge must have internet connectivity, it can work for limited time offline if the device has previously transmitted an upstream message. The network server Azure IoT Edge module and the Facade function have an API dependency on each other. its generally recommended for the deployments on the same source level. In addition we generally recommend as read the Azure IoT Edge trouble shooting guide","title":"Known Issues"},{"location":"issues/#known-issues-and-limitations","text":"","title":"Known Issues and Limitations"},{"location":"issues/#reporting-security-issues","text":"Security issues and bugs should be reported privately, via email, to the Microsoft Security Response Center (MSRC) at secure@microsoft.com . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Further information, including the MSRC PGP key, can be found in the Security TechCenter .","title":"Reporting Security Issues"},{"location":"issues/#limitations","text":"Tested only for EU868 and US915 frequency IoT Edge must have internet connectivity, it can work for limited time offline if the device has previously transmitted an upstream message. The network server Azure IoT Edge module and the Facade function have an API dependency on each other. its generally recommended for the deployments on the same source level. In addition we generally recommend as read the Azure IoT Edge trouble shooting guide","title":"Limitations"},{"location":"license/","text":"MIT License Copyright (c) Microsoft Corporation. All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE","title":"License"},{"location":"license/#mit-license","text":"Copyright (c) Microsoft Corporation. All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE","title":"MIT License"},{"location":"quickstart/","text":"Quick Start An Azure deployment template is available to deploy all the required Azure infrastructure and get you started quickly. If you'd rather deploy it manually please jump directly into the do it yourself section . Prerequisites The template supports x86 and ARM architectures and will automatically deploy the correct version to your gateway. Make sure to provide your gateway's reset pin in the dialog before the deployment. However, your gateway might use a different SPI_DEV or SPI_SPEED, and the Basics Station module could not work out-of-the-box. To fix this, refer to the Basics Station Module Configuration page. The LoRa device demo code in the Arduino folder is built only for Seeduino LoRaWan board and was not test with other Arduino LoRa boards. Deployed Azure Infrastructure The template will deploy in your Azure subscription the Following resources: IoT Hub Azure Function Redis Cache Application Insights Log Analytics (when opted in to use Azure Monitor) Step-by-step instructions Press on the button here below to start your Azure Deployment. You will get to a page asking you to fill the following fields : Resource Group - A logical \"folder\" where all the template resource would be put into, just choose a meaningful name. Location - In which DataCenter the resources should be deployed. Make sure to choose a location where IoT Hub is available Unique Solution Prefix - A string that would be used as prefix for all the resources name to ensure their uniqueness. Hence, avoid any standard prefix such as \"lora\" as it might already be in use and might make your deployment fail. NB: the template is creating a Storage account with the value specified here, therefore the naming restrictions of Storage apply here. Edge gateway name - the name of your LoRa Gateway node in the IoT Hub. Deploy Device - Do you want demo end devices to be already provisioned (one using OTAA and one using ABP )? If yes set this to true, the code located in the Arduino folder would be ready to use immediately. Reset pin - The reset pin of your gateway (the value should be 7 for the Seed Studio LoRaWam, 25 for the IC880A) Region - In what region are you operating your device (currently only EU868 and US915 is supported) useAzureMonitorOnEdge - You can opt out of using Azure Monitor services for observability on IoT Edge. The deployment would take c.a. 10 minutes to complete. During this time, you can proceed to install IoT Edge to your gateway . Once the Azure deployment is finished, connect your IoT Edge with the cloud as described in point 3 . You can get the connection string by clicking on the deployed IoT Hub -> IoT Edge Devices -> Connection string, as shown in the picture below. If your gateway is a Raspberry Pi, don't forget to enable SPI , (You need to restart your pi) . By using the docker ps command, you should see the Edge containers being deployed on your local gateway. You can now try one of the samples in the Arduino folder to see LoRa messages being sent to the cloud. If you have checked the Deploy Device checkbox you can use this sample directly \"TransmissionTestOTAALoRa.ino\" without provisioning the device first. What does the template do? The template provision an IoT Hub with a LoRa Basics\u2122 Station and a network server module already pre-configured to work out of the box. As soon as you connect your IoT Edge device in point 4 above, those will be pushed on your device. You can find template definition and Edge deployment specification here . If you are using the the RAK833-USB, you'll need to build a different LoRa Basics\u2122 Station image. You can find a fork of the official Basic Station repository with support for RAK833-USB here . Using a Proxy Server to connect your Concentrator to Azure This is an optional configuration that should only be executed if your concentrator needs to use a proxy server to communicate with Azure. Follow this guide to: Configure the Docker daemon and the IoT Edge daemon on your device to use a proxy server. Configure the edgeAgent properties in the config.yaml file on your device. Set environment variables for the IoT Edge runtime in the deployment manifest. Add the https_proxy environment variable to the LoRaWanNetworkSrvModule in IoT Hub. LoRa Device provisioning A LoRa device is a normal IoT Hub device with some specific device twin tags. You manage it like you would with any other IoT Hub device. To avoid caching issues you should not allow the device to join or send data before it is provisioned in IoT Hub. In case that you did plese follow the ClearCache procedure that you find below. ABP (personalization) and OTAA (over the air) provisioning You can provision the devices manually in the Azure portal or better use the provided Command Line Interface Provisioning Tool to list , query , verify , add , update , and remove devices in IoT Hub. It is also recommended to use the CLI tool to verify manually added or edited LoRa devices in IoT Hub to ensure the device twin settings are all correct and will work. To manually provision: Login in to the Azure portal go to IoT Hub -> IoT devices -> Add Use the DeviceEUI as DeviceID -> Save Click on the newly created device Click on Device Twin menu Add the followings desired properties for OTAA : \"desired\" : { \"AppEUI\" : \"App EUI\" , \"AppKey\" : \"App Key\" , \"GatewayID\" : \"\" , \"SensorDecoder\" : \"\" }, Or the followings desired properties for ABP : DevAddr must be unique for every device! It is like an ip address for lora. \"desired\" : { \"AppSKey\" : \"Device AppSKey\" , \"NwkSKey\" : \"Device NwkSKey\" , \"DevAddr\" : \"Device Addr\" , \"SensorDecoder\" : \"\" , \"GatewayID\" : \"\" }, It should look something like this for ABP : { \"deviceId\" : \"BE7A00000000888F\" , \"etag\" : \"AAAAAAAAAAs=\" , \"deviceEtag\" : \"NzMzMTE3MTAz\" , \"status\" : \"enabled\" , \"statusUpdateTime\" : \"0001-01-01T00:00:00\" , \"connectionState\" : \"Disconnected\" , \"lastActivityTime\" : \"2018-08-06T15:16:32.0658492\" , \"cloudToDeviceMessageCount\" : 0 , \"authenticationType\" : \"sas\" , \"x509Thumbprint\" : { \"primaryThumbprint\" : null , \"secondaryThumbprint\" : null }, \"version\" : 324 , \"tags\" : { }, \"properties\" : { \"desired\" : { \"AppSKey\" : \"2B7E151628AED2A6ABF7158809CF4F3C\" , \"NwkSKey\" : \"1B6E151628AED2A6ABF7158809CF4F2C\" , \"DevAddr\" : \"0028B9B9\" , \"SensorDecoder\" : \"\" , \"GatewayID\" : \"\" , \"$metadata\" : { \"$lastUpdated\" : \"2018-03-28T06:12:46.1007943Z\" }, \"$version\" : 1 }, \"reported\" : { \"$metadata\" : { \"$lastUpdated\" : \"2018-08-06T15:16:32.2689851Z\" }, \"$version\" : 313 } } } Click Save Turn on the device and you are ready to go Optional device properties Customization's to lora devices are set by creating specific twin desired properties on the device. The following customization's are available: Name Description Configuration When to use Enable/disable downstream messages Allows disabling the downstream (cloud to device) for a device. By default downstream messages are enabled Add twin desired property \"Downlink\": false to disable downstream messages. The absence of the twin property or setting value to true will enable downlink messages. Disabling downlink on devices decreases message processing latency, since the network server will not look for cloud to device messages when an uplink is received. Only disable it in devices that are not expecting messages from cloud. Acknowledgement of confirmed upstream are sent to devices even when downlink is set to false Preferred receive window Allows setting the device preferred receive window (RX1 or RX2). The default preferred receive window is 1 Add twin desired property \"PreferredWindow\": 2 sets RX2 as preferred window. The absence of the twin property or setting the value to 1 will set RX1 as preferred window. Using the second receive window increases the chances that the end application can process the upstream message and send a cloud to device message to the lora device without requiring and additional upstream message. Basically completing the round trip in less than 2 seconds. Message Deduplication Allows controlling the handling of duplicate messages received by multiple gateways.The default is None. Add twin desired property \"Deduplication\": \"Drop\" to instruct dropping duplicate messages on the gateway, set it to \"Mark\" if you want to mark messages to the IotHub with \"dupmsg\": true in case the message was already processed. Example payload: Device: [47AAC86800430028], Data:[{\"time\":null,\"tmms\":0,\"tmst\":3201165987,\"freq\":868.3,\"chan\":1,\"rfch\":1,\"stat\":1,\"modu\":\"LORA\",\"datr\":\"SF7BW125\",\"codr\":\"4/5\",\"rssi\":-61,\"lsnr\":8.2,\"size\":14,\"data\":{\"value\":1},\"port\":10,\"fcnt\":2,\"rawdata\":\"QImRWQIAAgAK8I3rbqc=\",\"eui\":\"47AAC86800430028\",\"gatewayid\":\"simulatorpaschule1\",\"edgets\":1550501633879, \"dupmsg\": true }] Deduplication on the gateway allows you to control how you want to handle duplicate messages in a multi gateway environment without having to add additional logic on the receiving or processing end. RX1 Datarate Offset Allows setting an offset between received Datarate and retransmit datarate as specified in the LoRa Specifiations. Valid for OTAA devices. If an invalid value is provided the network server will use default value 0. Add twin desired property \"RX1DROffset\": # where # is a valid specification number to create an offset of # between received Datarate and Transmit Datarate. Please find the full table in the LoRa Specification example: upstream DR2, with a RX1DROffset of 1 will result in a transmission on DR1 Setting an offset between receive and transmit could help deal with very saturated network. Warning, this is an advanced option, please only use if you are aware of your network specification. RX2 Datarate Allows setting a custom Datarate for second receive windows. Valid for OTAA devices. If an invalid value is provided the network server will use default value 0 (DR0). Add twin desired property \"RX2DataRate\": # where # is a valid specification number to set the RX2 DR to DR#. Example: if a value of 2 is provided, second receive windows will use DR2 instead of the default DR0. Setting a custom RX2 Datarate could help your RX2 devices to benefit of higher datarate. Warning, this is an advanced topic, changing it to higher datarate could be very dangerous and result in RX2 becoming unusable if the devices are not within reach of the specified datarate. Usage of this feature is especially not recommanded if ADR is enabled. RX Delay Allows setting a custom wait time between receiving and transmission as specified in the specification. Add twin desired property \"RXDelay\": # where # is a valid specification number to set the RxDelay to wait for # seconds. Note that values 0 and 1 are default. Example: if a value of 2 is provided, The RX1 transmit windows will open 2 second after receiving the message. RX2 windows will always stay 1 second after RX1 Setting a custom RXDelay could be usefull in case of long processing time, this could give more time to the server/device to compute their answers and lower the risk of missing the transmission windows. The defaults should work in most production scenarios, we recommend to use the default unless you have an explicit need for a longer delay Disable ABP relax mode Allows to disable the relax mode when using ABP . By default relaxed mode is enabled Add twin desired property \"ABPRelaxMode\": false will disable relaxed mode. Disable the relaxed mode to minimize reply attack possiblitites. Allowing relaxed mode, allows a device to reset framecounters on the server by specifying 0/1. Important : in production deployments, we recommend turning relaxed mode off Specify frame counter up start value Allows to explicitly specify a frame counter up start value. If the device joins, this value will be used to validate the first frame and initialize the server state for the device. Add twin desired property \"FCntUpStart\": 10 will set the frame counter up to 10. If you disable ABP relax mode (see ABPRelaxMode) you usually want to set this value. In general, if your device starts with anything but 0 or 1, you specify the value here. If your device has relaxed mode disabled or uses 32 bit counters and got out of sync, this is a way to re-synchronize the counter between the server and the device. see 32bit counter support and reset counter Specify frame counter down start value Allows to explicitly specify a frame counter down start value. Add twin desired property \"FCntDownStart\": 10 will set the frame counter up to 10. If your device expects a frame counter down other than 1 in the first message, use this to configure the value 32bit counter support Allow the usage of 32bit counters on your device. Add twin desired property \"Supports32BitFCnt\": true will enable 32bit support for your device. Your device will keep a 32bit counter but only sends the lower 16bit over the wire. The server will infere the upper 16bit by looking at the traffic. The additional 2 bytes increase security and minimize the reply atack surface Reset counter Allows to reset the frame counters to the FCntUpStart/FCntDownStart values respectively. Add twin desired property \"FCntResetCounter\": 1 will use the values specified in \"FCntUpStart\" and \"FCntDownStart\" to set the framecounters to the desired values. The \"FCntResetCounter\" in the desired properties has to be higher than the value in the reported properties for this to take effect. If there is no value in the reporte properties yet, it will be applied and the reported properties get updated, as soon as the counters got updated. If your device got out of sync (missed frames larger than the specified MAX_FCNT_GAP in the specification (16384 as of this writing)), you can re-synchronize the counters using this reset mechanism. Device Connection Timeout Allows defining a sliding expiration to the connection between the leaf device and IoT/Edge Hub. The default is none, which causes the connection to not be dropped Add twin desired property \"KeepAliveTimeout\": 60 to add a 60 seconds sliding expiration. The minimum value is 60 seconds. Enabling device connection timeout allows a large device deployment to have a better usage of gateway resources by limiting open connections. We don't recommend enabling connection timeout in devices that send confirmed messages and/or expected cloud to device messages, as the reconnection time might prevent the network server from responding in time. Important : changes made to twin desired properties in devices that are already connected will only take effect once the network server is restarted or cache is cleared . Device Reported Properties This section provide a brief description of the device reported properties you can see appear on your device. Name Description Used By DataRate The Device Current Datarate This value will be only reported if you are using Adaptive Data Rate TxPower The Device Current Transmit Power This value will be only reported if you are using Adaptive Data Rate NbRep The Device Current repetition when transmitting. E.g. if set to two, the device will transmit twice his upstream messages This value will be only reported if you are using Adaptive Data Rate RX2DataRate The Device Current Rx2Datarate This value will be only reported if you set a Custom property as specified in the previous section. The two values might differ as a device value is currently updated only as part of the join process. RX1DROffset The Device Current RX1DROffset This value will be only reported if you set a Custom property as specified in the previous section. The two values might differ as a device value is currently updated only as part of the join process. RXDelay The Device Current RXDelay This value will be only reported if you set a Custom property as specified in the previous section. The two values might differ as a device value is currently updated only as part of the join process. Decoders The SensorDecoder tag is used to define which method will be used to decode the LoRa payload. If you leave it out or empty it will send the raw decrypted payload in the data field of the json message as Base64 encoded value to IoT Hub. If you want to decode it on the Edge you have the following two options: Specify a method that implements the right logic in the LoraDecoders class in the LoraDecoders.cs file of the LoRaWan.NetworkServer . Adapt the DecoderSample which allows you to create and run your own LoRa message decoder in an independent container running on your LoRa gateway without having to edit the main LoRa Engine. This description shows you how to get started. In both cases, we have already provided a simple decoder called \"DecoderValueSensor\" that takes the whole payload as a single numeric value and constructs the following json output as a response (The example of an Arduino sending a sensor value as string (i.e. \"23.5\") is available in the Arduino folder ): { ..... \"data\" : { \"value\" : 23.5 } ..... } If you want the raw decrypted payload to be sent to IoT Hub as Hex encoded value in the data field of the json message, you can set the decoder to \"DecoderHexSensor\" . The byte array {1, 2, 4, 8, 255} for example will be converted to \"01020408FF\" by this built-in decoder. { ..... \"data\" : { \"value\" : \"01020408FF\" } ..... } To add the sample \"DecoderValueSensor\" or \"DecoderHexSensor \" to the sample LoRa device configured above, change it's desired properties in IoT Hub as follows for option 1: \"desired\" : { \"AppEUI\" : \"App EUI\" , \"AppKey\" : \"App Key\" , \"GatewayID\" : \"\" , \"SensorDecoder\" : \"DecoderValueSensor\" }, or as follows for option 2: \"desired\" : { \"AppEUI\" : \"App EUI\" , \"AppKey\" : \"App Key\" , \"GatewayID\" : \"\" , \"SensorDecoder\" : \"http://your_container_name/api/DecoderValueSensor\" }, The \"DecoderValueSensor\" and \"DecoderHexSensor\" decoders are not a best practice but it makes it easier to experiment sending sensor readings to IoT Hub without having to change any code. if the SensorDecoder tag has a \"http\" in it's string value, it will forward the decoding call to an external decoder, as described in option 2 above, using standard Http. The call expects a return value with the same format as the json here above or an error string. Cache Clearing Due to the gateway caching the device information (tags) for 1 day, if the device tries to connect before you have provisioned it, it will not be able to connect because it will be considered a device for another LoRa network. To clear the cache and allow the device to connect follow these steps: IoT Hub -> IoT Edge -> click on the device ID of your gateway Click on LoRaWanNetworkSrvModule Click Direct Method Type \"ClearCache\" on Method Name Click Invoke Method Alternatively you can restart the Gateway or the LoRaWanNetworkSrvModule container. Monitoring and Logging There is a logging mechanism that outputs valuable information to the console of the docker container and can optionally forward these messages to IoT Hub. You can control logging with the following environment variables in the LoRaWanNetworkSrvModule IoT Edge module: Variable Value Explanation LOG_LEVEL \"1\" or \"Debug\" Everything is logged, including the up- and downstream messages to the basic station. \"2\" or \"Information\" Errors and information are logged. \"3\" or \"Error\" Only errors are logged. (default if omitted) For production environments, the LOG_LEVEL should be set to Error . Setting LOG_LEVEL to Debug causes a lot of messages to be generated. Make sure to set LOG_TO_HUB to false in this case. Variable Value Explanation LOG_TO_HUB true Log info are sent from the module to IoT Hub. false Log info is not sent to IoT Hub (default if omitted) You can use VSCode or Azure IoT CLI extension to monitor the log messages directly in IoT Hub if LOG_TO_HUB is set to true . Log in to the gateway and use sudo docker logs LoRaWanNetworkSrvModule -f to follow the logs if you are not logging to IoT Hub. Variable Value Explanation LOG_TO_CONSOLE true Log to docker logs (default if omitted) false Does not log to docker logs Local Processing and Routing By default the network server does not use the local edge queue (edgeHub), sending directly messages to IoT Hub. If you need to do local processing, please set the following setting to true on the LoRaWanNetworkSrvModule . Variable Value Explanation ENABLE_GATEWAY true Messages go to edgeHub and then to IoT Hub false Messages go directly to IoT Hub, skipping local edgeHub Queue Customize the solution & Deep dive Have a look at the LoRaEngine folder for more in details explanation. Cloud to device message Sending cloud to device messages in the solution uses the following JSON format to describe the downstream: { \"devEUI\" : \"string\" , \"fport\" : i nte ger , \"confirmed\" : boolea n , \"payload\" : \"string\" , \"rawPayload\" : \"string\" , \"macCommands\" :[ { \"cid\" : \"string\" } ] } Fields Field Type Description Required devEUI String Device EUI Only when sending messages to class C devices fport Integer Payload fport, must be between 1 and 223 if you are sending data. 0 if it is Mac command Yes confirmed Boolean Indicates if an ack is required from the LoRa device. By default false No payload String Payload as text Either payload or rawPayload must be provided rawPayload String Payload as byte encoded in base64 format Either payload or rawPayload must be provided Mac command cid String Mac command identifier. The mac command DevStatusCmd is implemented, allowing you to request a device its status Sending messages using the Azure Function Sending messages to class A devices is a simple task, since those devices will send an upstream link giving the network server the chance of looking in Azure IoT Hub cloud to device message queue for pending downlink messages. Class C devices are complexer because they, for the most part, are only listening for messages. Using the cloud to message queue would not be very effective as it would require the network server to keep a client connection that would rarely be used, wasting resources. In this solution sending messages to class C devices is available through a direct method in the network server. However, in a multiple gateway scenario there is still the need to resolve the closest gateway before calling the relevant network server. The companion Azure Function deployed with the solution has a HTTP based endpoint to send messages to LoRa devices. It takes away the complexity of figuring out the device type and closest gateway. The function endpoint looks like https://YOUR-FUNCTION-NAME.azurewebsites.net/api/cloudtodevicemessage/{devEUI}?code=YOUR-FUNCTION-APP-CODE To send a message to a device send a POST request including the content as the body: curl -d '{\"rawPayload\": \"AAA=\",\"fport\": 1}' -H \"Content-Type: application/json\" https://YOUR-FUNCTION-NAME.azurewebsites.net/api/cloudtodevicemessage/YOUR-DEVEUI?code = YOUR-FUNCTION-APP-CODE Should return { \"devEUI\" : \"47AAC86800430028\" , \"messageID\" : \"10c3e09f-0e58-4d28-8da1-37bb3fcf9435\" , \"deviceClassType\" : \"A\" } Class A devices The solution support sending Cloud to device (C2D) messages to LoRa class A devices using standard IoT Hub SDKs . The message body should follow the following contract: The following tools can be used to send cloud to devices messages from Azure : Azure Portal \u2192 IoT Hub \u2192 Devices \u2192 message to device Azure IoT CLI Extension Visual Studio Code IoT Hub Extension In confirmed messages a ConfirmedDataDown message will be send to the LoRa device (as in picture above and below). You can enable additional message tracking options by setting the C2D message id to a value (C2D message ID is automatically populated with the Device Explorer tool used in the image below). As soon as the device acknowledges the message, it will report it in the logs and as a message property named 'C2DMsgConfirmed' on a message upstream (or generate an empty message in case of an empty ack message). The value of the message property will be set to the C2D message id that triggered the response if not null, otherwise to 'C2D Msg Confirmation'. You can find here below a set of picture illustrating the response when the C2D message id was sent to the value '4d3d0cd3-603a-4e00-a441-74aa55f53401'. Class C devices To send downstream messages to class C devices the following is required: The device twin desired property \"ClassType\": \"C\" must be set. The device must send at least one message upstream. Once the requirements are met, sending downstream messages is achieved by calling the direct method CloudToDeviceMessage in the module client. In Azure Portal: Azure Portal \u2192 IoT Hub \u2192 IoT Edge \u2192 LoRaWanNetworkSrvModule (under Modules) \u2192 Direct Method Visual Studio Code IoT Hub Extension The method name is CloudToDeviceMessage and the payload is the JSON following the structure previously described. Don't forget to set a value to the devEUI property. MAC Commands The Solution has an initial support for MAC Commands. Currently only the command Device Status is available. The command will return the device status (battery and communication margin). To try it, send a Cloud to Device message with the following format: { \"fport\" : 0 , \"macCommands\" : [ { \"cid\" : \"DevStatusCmd\" } ] }","title":"Quick Start"},{"location":"quickstart/#quick-start","text":"An Azure deployment template is available to deploy all the required Azure infrastructure and get you started quickly. If you'd rather deploy it manually please jump directly into the do it yourself section .","title":"Quick Start"},{"location":"quickstart/#prerequisites","text":"The template supports x86 and ARM architectures and will automatically deploy the correct version to your gateway. Make sure to provide your gateway's reset pin in the dialog before the deployment. However, your gateway might use a different SPI_DEV or SPI_SPEED, and the Basics Station module could not work out-of-the-box. To fix this, refer to the Basics Station Module Configuration page. The LoRa device demo code in the Arduino folder is built only for Seeduino LoRaWan board and was not test with other Arduino LoRa boards.","title":"Prerequisites"},{"location":"quickstart/#deployed-azure-infrastructure","text":"The template will deploy in your Azure subscription the Following resources: IoT Hub Azure Function Redis Cache Application Insights Log Analytics (when opted in to use Azure Monitor)","title":"Deployed Azure Infrastructure"},{"location":"quickstart/#step-by-step-instructions","text":"Press on the button here below to start your Azure Deployment. You will get to a page asking you to fill the following fields : Resource Group - A logical \"folder\" where all the template resource would be put into, just choose a meaningful name. Location - In which DataCenter the resources should be deployed. Make sure to choose a location where IoT Hub is available Unique Solution Prefix - A string that would be used as prefix for all the resources name to ensure their uniqueness. Hence, avoid any standard prefix such as \"lora\" as it might already be in use and might make your deployment fail. NB: the template is creating a Storage account with the value specified here, therefore the naming restrictions of Storage apply here. Edge gateway name - the name of your LoRa Gateway node in the IoT Hub. Deploy Device - Do you want demo end devices to be already provisioned (one using OTAA and one using ABP )? If yes set this to true, the code located in the Arduino folder would be ready to use immediately. Reset pin - The reset pin of your gateway (the value should be 7 for the Seed Studio LoRaWam, 25 for the IC880A) Region - In what region are you operating your device (currently only EU868 and US915 is supported) useAzureMonitorOnEdge - You can opt out of using Azure Monitor services for observability on IoT Edge. The deployment would take c.a. 10 minutes to complete. During this time, you can proceed to install IoT Edge to your gateway . Once the Azure deployment is finished, connect your IoT Edge with the cloud as described in point 3 . You can get the connection string by clicking on the deployed IoT Hub -> IoT Edge Devices -> Connection string, as shown in the picture below. If your gateway is a Raspberry Pi, don't forget to enable SPI , (You need to restart your pi) . By using the docker ps command, you should see the Edge containers being deployed on your local gateway. You can now try one of the samples in the Arduino folder to see LoRa messages being sent to the cloud. If you have checked the Deploy Device checkbox you can use this sample directly \"TransmissionTestOTAALoRa.ino\" without provisioning the device first.","title":"Step-by-step instructions"},{"location":"quickstart/#what-does-the-template-do","text":"The template provision an IoT Hub with a LoRa Basics\u2122 Station and a network server module already pre-configured to work out of the box. As soon as you connect your IoT Edge device in point 4 above, those will be pushed on your device. You can find template definition and Edge deployment specification here . If you are using the the RAK833-USB, you'll need to build a different LoRa Basics\u2122 Station image. You can find a fork of the official Basic Station repository with support for RAK833-USB here .","title":"What does the template do?"},{"location":"quickstart/#using-a-proxy-server-to-connect-your-concentrator-to-azure","text":"This is an optional configuration that should only be executed if your concentrator needs to use a proxy server to communicate with Azure. Follow this guide to: Configure the Docker daemon and the IoT Edge daemon on your device to use a proxy server. Configure the edgeAgent properties in the config.yaml file on your device. Set environment variables for the IoT Edge runtime in the deployment manifest. Add the https_proxy environment variable to the LoRaWanNetworkSrvModule in IoT Hub.","title":"Using a Proxy Server to connect your Concentrator to Azure"},{"location":"quickstart/#lora-device-provisioning","text":"A LoRa device is a normal IoT Hub device with some specific device twin tags. You manage it like you would with any other IoT Hub device. To avoid caching issues you should not allow the device to join or send data before it is provisioned in IoT Hub. In case that you did plese follow the ClearCache procedure that you find below.","title":"LoRa Device provisioning"},{"location":"quickstart/#abp-personalization-and-otaa-over-the-air-provisioning","text":"You can provision the devices manually in the Azure portal or better use the provided Command Line Interface Provisioning Tool to list , query , verify , add , update , and remove devices in IoT Hub. It is also recommended to use the CLI tool to verify manually added or edited LoRa devices in IoT Hub to ensure the device twin settings are all correct and will work. To manually provision: Login in to the Azure portal go to IoT Hub -> IoT devices -> Add Use the DeviceEUI as DeviceID -> Save Click on the newly created device Click on Device Twin menu Add the followings desired properties for OTAA : \"desired\" : { \"AppEUI\" : \"App EUI\" , \"AppKey\" : \"App Key\" , \"GatewayID\" : \"\" , \"SensorDecoder\" : \"\" }, Or the followings desired properties for ABP : DevAddr must be unique for every device! It is like an ip address for lora. \"desired\" : { \"AppSKey\" : \"Device AppSKey\" , \"NwkSKey\" : \"Device NwkSKey\" , \"DevAddr\" : \"Device Addr\" , \"SensorDecoder\" : \"\" , \"GatewayID\" : \"\" }, It should look something like this for ABP : { \"deviceId\" : \"BE7A00000000888F\" , \"etag\" : \"AAAAAAAAAAs=\" , \"deviceEtag\" : \"NzMzMTE3MTAz\" , \"status\" : \"enabled\" , \"statusUpdateTime\" : \"0001-01-01T00:00:00\" , \"connectionState\" : \"Disconnected\" , \"lastActivityTime\" : \"2018-08-06T15:16:32.0658492\" , \"cloudToDeviceMessageCount\" : 0 , \"authenticationType\" : \"sas\" , \"x509Thumbprint\" : { \"primaryThumbprint\" : null , \"secondaryThumbprint\" : null }, \"version\" : 324 , \"tags\" : { }, \"properties\" : { \"desired\" : { \"AppSKey\" : \"2B7E151628AED2A6ABF7158809CF4F3C\" , \"NwkSKey\" : \"1B6E151628AED2A6ABF7158809CF4F2C\" , \"DevAddr\" : \"0028B9B9\" , \"SensorDecoder\" : \"\" , \"GatewayID\" : \"\" , \"$metadata\" : { \"$lastUpdated\" : \"2018-03-28T06:12:46.1007943Z\" }, \"$version\" : 1 }, \"reported\" : { \"$metadata\" : { \"$lastUpdated\" : \"2018-08-06T15:16:32.2689851Z\" }, \"$version\" : 313 } } } Click Save Turn on the device and you are ready to go","title":"ABP (personalization) and OTAA (over the air) provisioning"},{"location":"quickstart/#optional-device-properties","text":"Customization's to lora devices are set by creating specific twin desired properties on the device. The following customization's are available: Name Description Configuration When to use Enable/disable downstream messages Allows disabling the downstream (cloud to device) for a device. By default downstream messages are enabled Add twin desired property \"Downlink\": false to disable downstream messages. The absence of the twin property or setting value to true will enable downlink messages. Disabling downlink on devices decreases message processing latency, since the network server will not look for cloud to device messages when an uplink is received. Only disable it in devices that are not expecting messages from cloud. Acknowledgement of confirmed upstream are sent to devices even when downlink is set to false Preferred receive window Allows setting the device preferred receive window (RX1 or RX2). The default preferred receive window is 1 Add twin desired property \"PreferredWindow\": 2 sets RX2 as preferred window. The absence of the twin property or setting the value to 1 will set RX1 as preferred window. Using the second receive window increases the chances that the end application can process the upstream message and send a cloud to device message to the lora device without requiring and additional upstream message. Basically completing the round trip in less than 2 seconds. Message Deduplication Allows controlling the handling of duplicate messages received by multiple gateways.The default is None. Add twin desired property \"Deduplication\": \"Drop\" to instruct dropping duplicate messages on the gateway, set it to \"Mark\" if you want to mark messages to the IotHub with \"dupmsg\": true in case the message was already processed. Example payload: Device: [47AAC86800430028], Data:[{\"time\":null,\"tmms\":0,\"tmst\":3201165987,\"freq\":868.3,\"chan\":1,\"rfch\":1,\"stat\":1,\"modu\":\"LORA\",\"datr\":\"SF7BW125\",\"codr\":\"4/5\",\"rssi\":-61,\"lsnr\":8.2,\"size\":14,\"data\":{\"value\":1},\"port\":10,\"fcnt\":2,\"rawdata\":\"QImRWQIAAgAK8I3rbqc=\",\"eui\":\"47AAC86800430028\",\"gatewayid\":\"simulatorpaschule1\",\"edgets\":1550501633879, \"dupmsg\": true }] Deduplication on the gateway allows you to control how you want to handle duplicate messages in a multi gateway environment without having to add additional logic on the receiving or processing end. RX1 Datarate Offset Allows setting an offset between received Datarate and retransmit datarate as specified in the LoRa Specifiations. Valid for OTAA devices. If an invalid value is provided the network server will use default value 0. Add twin desired property \"RX1DROffset\": # where # is a valid specification number to create an offset of # between received Datarate and Transmit Datarate. Please find the full table in the LoRa Specification example: upstream DR2, with a RX1DROffset of 1 will result in a transmission on DR1 Setting an offset between receive and transmit could help deal with very saturated network. Warning, this is an advanced option, please only use if you are aware of your network specification. RX2 Datarate Allows setting a custom Datarate for second receive windows. Valid for OTAA devices. If an invalid value is provided the network server will use default value 0 (DR0). Add twin desired property \"RX2DataRate\": # where # is a valid specification number to set the RX2 DR to DR#. Example: if a value of 2 is provided, second receive windows will use DR2 instead of the default DR0. Setting a custom RX2 Datarate could help your RX2 devices to benefit of higher datarate. Warning, this is an advanced topic, changing it to higher datarate could be very dangerous and result in RX2 becoming unusable if the devices are not within reach of the specified datarate. Usage of this feature is especially not recommanded if ADR is enabled. RX Delay Allows setting a custom wait time between receiving and transmission as specified in the specification. Add twin desired property \"RXDelay\": # where # is a valid specification number to set the RxDelay to wait for # seconds. Note that values 0 and 1 are default. Example: if a value of 2 is provided, The RX1 transmit windows will open 2 second after receiving the message. RX2 windows will always stay 1 second after RX1 Setting a custom RXDelay could be usefull in case of long processing time, this could give more time to the server/device to compute their answers and lower the risk of missing the transmission windows. The defaults should work in most production scenarios, we recommend to use the default unless you have an explicit need for a longer delay Disable ABP relax mode Allows to disable the relax mode when using ABP . By default relaxed mode is enabled Add twin desired property \"ABPRelaxMode\": false will disable relaxed mode. Disable the relaxed mode to minimize reply attack possiblitites. Allowing relaxed mode, allows a device to reset framecounters on the server by specifying 0/1. Important : in production deployments, we recommend turning relaxed mode off Specify frame counter up start value Allows to explicitly specify a frame counter up start value. If the device joins, this value will be used to validate the first frame and initialize the server state for the device. Add twin desired property \"FCntUpStart\": 10 will set the frame counter up to 10. If you disable ABP relax mode (see ABPRelaxMode) you usually want to set this value. In general, if your device starts with anything but 0 or 1, you specify the value here. If your device has relaxed mode disabled or uses 32 bit counters and got out of sync, this is a way to re-synchronize the counter between the server and the device. see 32bit counter support and reset counter Specify frame counter down start value Allows to explicitly specify a frame counter down start value. Add twin desired property \"FCntDownStart\": 10 will set the frame counter up to 10. If your device expects a frame counter down other than 1 in the first message, use this to configure the value 32bit counter support Allow the usage of 32bit counters on your device. Add twin desired property \"Supports32BitFCnt\": true will enable 32bit support for your device. Your device will keep a 32bit counter but only sends the lower 16bit over the wire. The server will infere the upper 16bit by looking at the traffic. The additional 2 bytes increase security and minimize the reply atack surface Reset counter Allows to reset the frame counters to the FCntUpStart/FCntDownStart values respectively. Add twin desired property \"FCntResetCounter\": 1 will use the values specified in \"FCntUpStart\" and \"FCntDownStart\" to set the framecounters to the desired values. The \"FCntResetCounter\" in the desired properties has to be higher than the value in the reported properties for this to take effect. If there is no value in the reporte properties yet, it will be applied and the reported properties get updated, as soon as the counters got updated. If your device got out of sync (missed frames larger than the specified MAX_FCNT_GAP in the specification (16384 as of this writing)), you can re-synchronize the counters using this reset mechanism. Device Connection Timeout Allows defining a sliding expiration to the connection between the leaf device and IoT/Edge Hub. The default is none, which causes the connection to not be dropped Add twin desired property \"KeepAliveTimeout\": 60 to add a 60 seconds sliding expiration. The minimum value is 60 seconds. Enabling device connection timeout allows a large device deployment to have a better usage of gateway resources by limiting open connections. We don't recommend enabling connection timeout in devices that send confirmed messages and/or expected cloud to device messages, as the reconnection time might prevent the network server from responding in time. Important : changes made to twin desired properties in devices that are already connected will only take effect once the network server is restarted or cache is cleared .","title":"Optional device properties"},{"location":"quickstart/#device-reported-properties","text":"This section provide a brief description of the device reported properties you can see appear on your device. Name Description Used By DataRate The Device Current Datarate This value will be only reported if you are using Adaptive Data Rate TxPower The Device Current Transmit Power This value will be only reported if you are using Adaptive Data Rate NbRep The Device Current repetition when transmitting. E.g. if set to two, the device will transmit twice his upstream messages This value will be only reported if you are using Adaptive Data Rate RX2DataRate The Device Current Rx2Datarate This value will be only reported if you set a Custom property as specified in the previous section. The two values might differ as a device value is currently updated only as part of the join process. RX1DROffset The Device Current RX1DROffset This value will be only reported if you set a Custom property as specified in the previous section. The two values might differ as a device value is currently updated only as part of the join process. RXDelay The Device Current RXDelay This value will be only reported if you set a Custom property as specified in the previous section. The two values might differ as a device value is currently updated only as part of the join process.","title":"Device Reported Properties"},{"location":"quickstart/#decoders","text":"The SensorDecoder tag is used to define which method will be used to decode the LoRa payload. If you leave it out or empty it will send the raw decrypted payload in the data field of the json message as Base64 encoded value to IoT Hub. If you want to decode it on the Edge you have the following two options: Specify a method that implements the right logic in the LoraDecoders class in the LoraDecoders.cs file of the LoRaWan.NetworkServer . Adapt the DecoderSample which allows you to create and run your own LoRa message decoder in an independent container running on your LoRa gateway without having to edit the main LoRa Engine. This description shows you how to get started. In both cases, we have already provided a simple decoder called \"DecoderValueSensor\" that takes the whole payload as a single numeric value and constructs the following json output as a response (The example of an Arduino sending a sensor value as string (i.e. \"23.5\") is available in the Arduino folder ): { ..... \"data\" : { \"value\" : 23.5 } ..... } If you want the raw decrypted payload to be sent to IoT Hub as Hex encoded value in the data field of the json message, you can set the decoder to \"DecoderHexSensor\" . The byte array {1, 2, 4, 8, 255} for example will be converted to \"01020408FF\" by this built-in decoder. { ..... \"data\" : { \"value\" : \"01020408FF\" } ..... } To add the sample \"DecoderValueSensor\" or \"DecoderHexSensor \" to the sample LoRa device configured above, change it's desired properties in IoT Hub as follows for option 1: \"desired\" : { \"AppEUI\" : \"App EUI\" , \"AppKey\" : \"App Key\" , \"GatewayID\" : \"\" , \"SensorDecoder\" : \"DecoderValueSensor\" }, or as follows for option 2: \"desired\" : { \"AppEUI\" : \"App EUI\" , \"AppKey\" : \"App Key\" , \"GatewayID\" : \"\" , \"SensorDecoder\" : \"http://your_container_name/api/DecoderValueSensor\" }, The \"DecoderValueSensor\" and \"DecoderHexSensor\" decoders are not a best practice but it makes it easier to experiment sending sensor readings to IoT Hub without having to change any code. if the SensorDecoder tag has a \"http\" in it's string value, it will forward the decoding call to an external decoder, as described in option 2 above, using standard Http. The call expects a return value with the same format as the json here above or an error string.","title":"Decoders"},{"location":"quickstart/#cache-clearing","text":"Due to the gateway caching the device information (tags) for 1 day, if the device tries to connect before you have provisioned it, it will not be able to connect because it will be considered a device for another LoRa network. To clear the cache and allow the device to connect follow these steps: IoT Hub -> IoT Edge -> click on the device ID of your gateway Click on LoRaWanNetworkSrvModule Click Direct Method Type \"ClearCache\" on Method Name Click Invoke Method Alternatively you can restart the Gateway or the LoRaWanNetworkSrvModule container.","title":"Cache Clearing"},{"location":"quickstart/#monitoring-and-logging","text":"There is a logging mechanism that outputs valuable information to the console of the docker container and can optionally forward these messages to IoT Hub. You can control logging with the following environment variables in the LoRaWanNetworkSrvModule IoT Edge module: Variable Value Explanation LOG_LEVEL \"1\" or \"Debug\" Everything is logged, including the up- and downstream messages to the basic station. \"2\" or \"Information\" Errors and information are logged. \"3\" or \"Error\" Only errors are logged. (default if omitted) For production environments, the LOG_LEVEL should be set to Error . Setting LOG_LEVEL to Debug causes a lot of messages to be generated. Make sure to set LOG_TO_HUB to false in this case. Variable Value Explanation LOG_TO_HUB true Log info are sent from the module to IoT Hub. false Log info is not sent to IoT Hub (default if omitted) You can use VSCode or Azure IoT CLI extension to monitor the log messages directly in IoT Hub if LOG_TO_HUB is set to true . Log in to the gateway and use sudo docker logs LoRaWanNetworkSrvModule -f to follow the logs if you are not logging to IoT Hub. Variable Value Explanation LOG_TO_CONSOLE true Log to docker logs (default if omitted) false Does not log to docker logs","title":"Monitoring and Logging"},{"location":"quickstart/#local-processing-and-routing","text":"By default the network server does not use the local edge queue (edgeHub), sending directly messages to IoT Hub. If you need to do local processing, please set the following setting to true on the LoRaWanNetworkSrvModule . Variable Value Explanation ENABLE_GATEWAY true Messages go to edgeHub and then to IoT Hub false Messages go directly to IoT Hub, skipping local edgeHub Queue","title":"Local Processing and Routing"},{"location":"quickstart/#customize-the-solution-deep-dive","text":"Have a look at the LoRaEngine folder for more in details explanation.","title":"Customize the solution &amp; Deep dive"},{"location":"quickstart/#cloud-to-device-message","text":"Sending cloud to device messages in the solution uses the following JSON format to describe the downstream: { \"devEUI\" : \"string\" , \"fport\" : i nte ger , \"confirmed\" : boolea n , \"payload\" : \"string\" , \"rawPayload\" : \"string\" , \"macCommands\" :[ { \"cid\" : \"string\" } ] }","title":"Cloud to device message"},{"location":"quickstart/#fields","text":"Field Type Description Required devEUI String Device EUI Only when sending messages to class C devices fport Integer Payload fport, must be between 1 and 223 if you are sending data. 0 if it is Mac command Yes confirmed Boolean Indicates if an ack is required from the LoRa device. By default false No payload String Payload as text Either payload or rawPayload must be provided rawPayload String Payload as byte encoded in base64 format Either payload or rawPayload must be provided Mac command cid String Mac command identifier. The mac command DevStatusCmd is implemented, allowing you to request a device its status","title":"Fields"},{"location":"quickstart/#sending-messages-using-the-azure-function","text":"Sending messages to class A devices is a simple task, since those devices will send an upstream link giving the network server the chance of looking in Azure IoT Hub cloud to device message queue for pending downlink messages. Class C devices are complexer because they, for the most part, are only listening for messages. Using the cloud to message queue would not be very effective as it would require the network server to keep a client connection that would rarely be used, wasting resources. In this solution sending messages to class C devices is available through a direct method in the network server. However, in a multiple gateway scenario there is still the need to resolve the closest gateway before calling the relevant network server. The companion Azure Function deployed with the solution has a HTTP based endpoint to send messages to LoRa devices. It takes away the complexity of figuring out the device type and closest gateway. The function endpoint looks like https://YOUR-FUNCTION-NAME.azurewebsites.net/api/cloudtodevicemessage/{devEUI}?code=YOUR-FUNCTION-APP-CODE To send a message to a device send a POST request including the content as the body: curl -d '{\"rawPayload\": \"AAA=\",\"fport\": 1}' -H \"Content-Type: application/json\" https://YOUR-FUNCTION-NAME.azurewebsites.net/api/cloudtodevicemessage/YOUR-DEVEUI?code = YOUR-FUNCTION-APP-CODE Should return { \"devEUI\" : \"47AAC86800430028\" , \"messageID\" : \"10c3e09f-0e58-4d28-8da1-37bb3fcf9435\" , \"deviceClassType\" : \"A\" }","title":"Sending messages using the Azure Function"},{"location":"quickstart/#class-a-devices","text":"The solution support sending Cloud to device (C2D) messages to LoRa class A devices using standard IoT Hub SDKs . The message body should follow the following contract: The following tools can be used to send cloud to devices messages from Azure : Azure Portal \u2192 IoT Hub \u2192 Devices \u2192 message to device Azure IoT CLI Extension Visual Studio Code IoT Hub Extension In confirmed messages a ConfirmedDataDown message will be send to the LoRa device (as in picture above and below). You can enable additional message tracking options by setting the C2D message id to a value (C2D message ID is automatically populated with the Device Explorer tool used in the image below). As soon as the device acknowledges the message, it will report it in the logs and as a message property named 'C2DMsgConfirmed' on a message upstream (or generate an empty message in case of an empty ack message). The value of the message property will be set to the C2D message id that triggered the response if not null, otherwise to 'C2D Msg Confirmation'. You can find here below a set of picture illustrating the response when the C2D message id was sent to the value '4d3d0cd3-603a-4e00-a441-74aa55f53401'.","title":"Class A devices"},{"location":"quickstart/#class-c-devices","text":"To send downstream messages to class C devices the following is required: The device twin desired property \"ClassType\": \"C\" must be set. The device must send at least one message upstream. Once the requirements are met, sending downstream messages is achieved by calling the direct method CloudToDeviceMessage in the module client. In Azure Portal: Azure Portal \u2192 IoT Hub \u2192 IoT Edge \u2192 LoRaWanNetworkSrvModule (under Modules) \u2192 Direct Method Visual Studio Code IoT Hub Extension The method name is CloudToDeviceMessage and the payload is the JSON following the structure previously described. Don't forget to set a value to the devEUI property.","title":"Class C devices"},{"location":"quickstart/#mac-commands","text":"The Solution has an initial support for MAC Commands. Currently only the command Device Status is available. The command will return the device status (battery and communication margin). To try it, send a Cloud to Device message with the following format: { \"fport\" : 0 , \"macCommands\" : [ { \"cid\" : \"DevStatusCmd\" } ] }","title":"MAC Commands"},{"location":"support/","text":"Support The LoRaWAN starter kit is an open source solution, it is NOT a Microsoft supported solution or product. For bugs and issues with the codebase please log an issue in this repo.","title":"Support"},{"location":"support/#support","text":"The LoRaWAN starter kit is an open source solution, it is NOT a Microsoft supported solution or product. For bugs and issues with the codebase please log an issue in this repo.","title":"Support"},{"location":"adr/001_region_cn470_implementation/","text":"001. Region CN470 implementation Milestone / Epic: #416 Authors: Maggie Salak, Mikhail Chatillon Overview / Problem Statement The specification of region CN470 has significant differences compared to regions already supported by the Starterkit. Specifically, there are 4 different frequency channel plans involved and calculation of downstream frequencies requires knowing which channel plan has been activated for a given device during join or device provisioning: Plan A for 20 MHz antennas Plan B for 20 MHz antennas Plan A for 26 MHz antennas Plan B for 26 MHz antennas This document summarizes decisions taken for the purpose of implementing support for region CN470. In-Scope Support for OTAA and ABP devices Correct handling of join requests Calculation of downstream frequencies and data rates Calculation of RX2 default frequency Out-of-scope MAC commands - support for MAC commands will be added later on Choices OTAA join channel is needed to determine which channel plan should be activated for a given device and used when calculating downstream frequency. We plan to save the join channel index in the device twin inside reported properties in IoT Hub. The property would be named CN470JoinChannel and the value would be an int in range 0 - 19, corresponding to the 20 possible join channels. According to the specification , multiple join channels map to the same channel plan, e.g. join channels 0 - 7 are all mapped to Plan A for 20 MHz devices, where each of them has a different frequency. In total there are 20 possible join channels mapped to 4 channel plans as described in Overview. The join channel is also needed for computing the RX2 default frequency. In this case the join channel index directly determines the correct RX2 default frequency. In case of ABP devices the channel plan will need to be provisioned on the IoT Hub by the operator in the desired properties of the device twin, since there is no device join in this scenario. For simplicity of the implementation, the channel plan will be stored in the same way as in case of OTAA devices; it would be saved as a join channel index (named CN470JoinChannel as in case of OTAA) using the following table for determining the correct value: Channel plan CN470JoinChannel 20 MHz Plan A 0 20 MHz Plan B 8 26 MHz Plan A 10 26 MHz Plan B 15 Since there are no join channels in case of ABP devices, we will define a convention as to which channel index should be used for each channel plan. The suggested way would be to use the lowest index for each of the 4 channel plans, as in the table above. In the implementation of the region, we will first check if a join channel is set in the reported properties and, if not, we will retrieve it from desired properties. This will also give us the information whether a given device is an OTAA or ABP device.This is needed when calculating the RX2 default frequency. In case of OTAA devices we need to calculated it using the join channel index but in case of ABP it's a constant value.","title":"001. Region CN470 implementation"},{"location":"adr/001_region_cn470_implementation/#001-region-cn470-implementation","text":"Milestone / Epic: #416 Authors: Maggie Salak, Mikhail Chatillon","title":"001. Region CN470 implementation"},{"location":"adr/001_region_cn470_implementation/#overview-problem-statement","text":"The specification of region CN470 has significant differences compared to regions already supported by the Starterkit. Specifically, there are 4 different frequency channel plans involved and calculation of downstream frequencies requires knowing which channel plan has been activated for a given device during join or device provisioning: Plan A for 20 MHz antennas Plan B for 20 MHz antennas Plan A for 26 MHz antennas Plan B for 26 MHz antennas This document summarizes decisions taken for the purpose of implementing support for region CN470.","title":"Overview / Problem Statement"},{"location":"adr/001_region_cn470_implementation/#in-scope","text":"Support for OTAA and ABP devices Correct handling of join requests Calculation of downstream frequencies and data rates Calculation of RX2 default frequency","title":"In-Scope"},{"location":"adr/001_region_cn470_implementation/#out-of-scope","text":"MAC commands - support for MAC commands will be added later on","title":"Out-of-scope"},{"location":"adr/001_region_cn470_implementation/#choices","text":"OTAA join channel is needed to determine which channel plan should be activated for a given device and used when calculating downstream frequency. We plan to save the join channel index in the device twin inside reported properties in IoT Hub. The property would be named CN470JoinChannel and the value would be an int in range 0 - 19, corresponding to the 20 possible join channels. According to the specification , multiple join channels map to the same channel plan, e.g. join channels 0 - 7 are all mapped to Plan A for 20 MHz devices, where each of them has a different frequency. In total there are 20 possible join channels mapped to 4 channel plans as described in Overview. The join channel is also needed for computing the RX2 default frequency. In this case the join channel index directly determines the correct RX2 default frequency. In case of ABP devices the channel plan will need to be provisioned on the IoT Hub by the operator in the desired properties of the device twin, since there is no device join in this scenario. For simplicity of the implementation, the channel plan will be stored in the same way as in case of OTAA devices; it would be saved as a join channel index (named CN470JoinChannel as in case of OTAA) using the following table for determining the correct value: Channel plan CN470JoinChannel 20 MHz Plan A 0 20 MHz Plan B 8 26 MHz Plan A 10 26 MHz Plan B 15 Since there are no join channels in case of ABP devices, we will define a convention as to which channel index should be used for each channel plan. The suggested way would be to use the lowest index for each of the 4 channel plans, as in the table above. In the implementation of the region, we will first check if a join channel is set in the reported properties and, if not, we will retrieve it from desired properties. This will also give us the information whether a given device is an OTAA or ABP device.This is needed when calculating the RX2 default frequency. In case of OTAA devices we need to calculated it using the join channel index but in case of ABP it's a constant value.","title":"Choices"},{"location":"adr/002_lbs_configuration/","text":"002. LoRa Basic Station configuration endpoint implementation Milestone / Epic: #388 Authors: Bastian Burger, Spyros Giannakakis Overview / Problem Statement The LNS protocol specifies an endpoint that the LoRa Basic Station (LBS) invokes an endpoint on the LNS to load its configuration. After a successful configuration exchange, the LBS/LNS start to operate normally. From the protocol specification Right after the WebSocket connection has been established, the Station sends a version message. Next, the LNS shall respond with a router_config message. Afterwards, normal operation begins with uplink/downlink messages as described below. As part of this ADR we describe how the LNS can provide the LBS with the necessary configuration. We analyze different strategies with respect to their implementation simplicity, deployment simplicity and how to detect updates to the configuration. Restrictions / limitations Twins have a limit of 32KB for desired properties. Children devices can only have one parent and a parent can have up to 100 children devices. Possible solutions Option 1: Mount volume on LNS with the LBS configuration Since the LNS runs as an IoT edge module, we can use IoT Edge device local storage from a module . We would store the configuration of all LBSs in the file system of the LNS. Advantages : Implementation effort is low. No limitation in terms of how many LBSs can connect to an LNS. Disadvantages : An additional configuration mechanism besides the IoT Hub is introduced to the system. This would complicate the provisioning flow and potentially require the involvement of a separate infra team. Deployment of updated configuration is not straightforward, since for configuration updates we need access to the file system of where the LNS is hosted. To check if the configuration changed, we would also need to query the configuration file(s) periodically to detect changes and apply updates. Option 2: Hold LBS configurations in the LNS module twin Adding the configuration to the module twin of the LNS would make it possible to update the LBS configuration (e.g. adding new gateways, changing existing values) by adapting the module twin of the LNS. Since device twins have a 32kb size limit for desired properties , this means that we will have an effective limitation in terms of how many LBS we can connect to a single LNS. The device twin documentation states the following about the encoding of the twin desired properties: Property key is encoded as UTF-8-encoded string (usually one character takes 8 bytes) Boolean value takes 4 bytes Numeric value takes 8 bytes Nested object size is based on their content Taking as an example the configuration message from PR 569 , we are able to add 37 times the following LBS configuration to the device twins desired properties until we get an error: { \"msgtype\" : \"router_config\" , \"NetID\" :[ 1 ], \"JoinEui\" :[ \"9223372036854775807\" , \"9223372036854775807\" ], \"region\" : \"EU863\" , \"hwspec\" : \"sx1301/1\" , \"freq_range\" :[ 863000000 , 870000000 ], \"DRs\" :[[ 11 , 125 , 0 ],[ 10 , 125 , 0 ],[ 9 , 125 , 0 ],[ 8 , 125 , 0 ],[ 7 , 125 , 0 ],[ 7 , 250 , 0 ]], \"sx1301_conf\" :[{ \"radio_0\" :{ \"enable\" : true , \"freq\" : 867500000 }, \"radio_1\" :{ \"enable\" : true , \"freq\" : 868500000 }, \"chan_FSK\" :{ \"enable\" : true , \"radio\" : 1 , \"if\" : 300000 }, \"chan_Lora_std\" :{ \"enable\" : true , \"radio\" : 1 , \"if\" : -200000 , \"bandwidth\" : 250000 , \"spread_factor\" : 7 }, \"chan_multiSF_0\" :{ \"enable\" : true , \"radio\" : 1 , \"if\" : -400000 }, \"chan_multiSF_1\" :{ \"enable\" : true , \"radio\" : 1 , \"if\" : -200000 }, \"chan_multiSF_2\" :{ \"enable\" : true , \"radio\" : 1 , \"if\" : 0 }, \"chan_multiSF_3\" :{ \"enable\" : true , \"radio\" : 0 , \"if\" : -400000 }, \"chan_multiSF_4\" :{ \"enable\" : true , \"radio\" : 0 , \"if\" : -200000 }, \"chan_multiSF_5\" :{ \"enable\" : true , \"radio\" : 0 , \"if\" : 0 }, \"chan_multiSF_6\" :{ \"enable\" : true , \"radio\" : 0 , \"if\" : 200000 }, \"chan_multiSF_7\" :{ \"enable\" : true , \"radio\" : 0 , \"if\" : 400000 }}], \"nocca\" : true , \"nodc\" : true , \"nodwell\" : true } Assuming that we do not choose a different representation (e.g. compression, sharing of duplicated parts of the document) we can safely guarantee that we support 30 gateways per network server with this approach. NB : In case the specification requires us to transfer 64-bit numbers (e.g. for EUIs), we either need to split up such a number into two 32-bit numbers or represent it as a string. Device twins encode numbers as 32-bit values. Advantages : We can fetch the LBS configuration needing to have access to the contentrator device key (as in Option 3). No need to create additional IoT devices for each LBS. Configuration of all LBSs is centralized in one place which would make it easier to find. Disadvantages : The centralization of configuration complicates the changes needed to connect to other or multiple LNSs (for dynamic discovery or resiliency purposes) The limit of ~30 LBSs per LNS is considered enough for now (initially we considered 4-5 LBSs per LNS) but could be limiting in the future especially if the twins grow. Workarounds can be considered e.g. use this space only for non-default LBSs or potentially compress. Option 3: Track each LBS as separate IoT Hub device In this option, we create IoT Hub devices (not edge-enabled) for every LBS. The configuration of LBS is held in the device twin. Open question : Do we allow an LNS to get info for any LBS or only for the ones that are connected to it? LNS uses the Azure Function to retrieve the device key LBS requests its configuration passing its device id. LNS invokes the existing Azure Function to get the Device key passing the LBS id. The Function returns the Device Key (via a cache or by querying IoT Hub). LNS uses the Device Key to impersonate LBS, get its twin that holds the configuration (optionally: listens to future updates to it by DeviceClient.SetDesiredPropertyUpdateCallbackAsync ). Notes: Code changes are not extensive, as most of the code change is already there Advantages : LBSs are self-contained and therefore can be moved more easily for example to a different LNS (discovery phase) or connect to more than one LNS (resiliency). Disadvantages : We would need to provision and manage IoT devices for LBSs. More complex LNS flow since it involves the Function. Possible delay, though there is no timeout window within which we need to respond. Multiple open connections are required for each LBS. Alternative 1: utilize the child-parent feature to avoid invoking additional Azure services By establishing a child-parent relationship between LBSs and LNS, messages from and to LBS are passed transparently through the LNS. The idea here would be that LNS as the parent, has access to the LBS device twin without the need to use the LBS device key. Reason for disqualifying: There seems that there is no API in either the DeviceClient nor the ModuleClient to retrieve the device twin of a child without having the device key. Alternative 2: edge-enabled LBS sends upstream its twin to LNS If LBS was an IoT Edge enabled device, we could utilize ModuleClient.SetDesiredPropertyUpdateCallbackAsync to send upstream to its parent the updated module twin. LNS could filter messages coming from downstream/child devices based on whether they contain a module id or not to get a hold of this configuration. Reason for disqualifying: Given that LBS needs to run on low powered devices, we can not change them to IoT Edge enabled devices. Decision Based on this investigation and the team discussion, Option 3 was chosen due to the flexibility it offers in terms of use-cases (resiliency, dynamic discovery) as well as scaling options. The additional complexity is deemed reasonable given the additional future-proofness.","title":"002. LoRa Basic Station configuration endpoint implementation"},{"location":"adr/002_lbs_configuration/#002-lora-basic-station-configuration-endpoint-implementation","text":"Milestone / Epic: #388 Authors: Bastian Burger, Spyros Giannakakis","title":"002. LoRa Basic Station configuration endpoint implementation"},{"location":"adr/002_lbs_configuration/#overview-problem-statement","text":"The LNS protocol specifies an endpoint that the LoRa Basic Station (LBS) invokes an endpoint on the LNS to load its configuration. After a successful configuration exchange, the LBS/LNS start to operate normally. From the protocol specification Right after the WebSocket connection has been established, the Station sends a version message. Next, the LNS shall respond with a router_config message. Afterwards, normal operation begins with uplink/downlink messages as described below. As part of this ADR we describe how the LNS can provide the LBS with the necessary configuration. We analyze different strategies with respect to their implementation simplicity, deployment simplicity and how to detect updates to the configuration.","title":"Overview / Problem Statement"},{"location":"adr/002_lbs_configuration/#restrictions-limitations","text":"Twins have a limit of 32KB for desired properties. Children devices can only have one parent and a parent can have up to 100 children devices.","title":"Restrictions / limitations"},{"location":"adr/002_lbs_configuration/#possible-solutions","text":"","title":"Possible solutions"},{"location":"adr/002_lbs_configuration/#option-1-mount-volume-on-lns-with-the-lbs-configuration","text":"Since the LNS runs as an IoT edge module, we can use IoT Edge device local storage from a module . We would store the configuration of all LBSs in the file system of the LNS. Advantages : Implementation effort is low. No limitation in terms of how many LBSs can connect to an LNS. Disadvantages : An additional configuration mechanism besides the IoT Hub is introduced to the system. This would complicate the provisioning flow and potentially require the involvement of a separate infra team. Deployment of updated configuration is not straightforward, since for configuration updates we need access to the file system of where the LNS is hosted. To check if the configuration changed, we would also need to query the configuration file(s) periodically to detect changes and apply updates.","title":"Option 1: Mount volume on LNS with the LBS configuration"},{"location":"adr/002_lbs_configuration/#option-2-hold-lbs-configurations-in-the-lns-module-twin","text":"Adding the configuration to the module twin of the LNS would make it possible to update the LBS configuration (e.g. adding new gateways, changing existing values) by adapting the module twin of the LNS. Since device twins have a 32kb size limit for desired properties , this means that we will have an effective limitation in terms of how many LBS we can connect to a single LNS. The device twin documentation states the following about the encoding of the twin desired properties: Property key is encoded as UTF-8-encoded string (usually one character takes 8 bytes) Boolean value takes 4 bytes Numeric value takes 8 bytes Nested object size is based on their content Taking as an example the configuration message from PR 569 , we are able to add 37 times the following LBS configuration to the device twins desired properties until we get an error: { \"msgtype\" : \"router_config\" , \"NetID\" :[ 1 ], \"JoinEui\" :[ \"9223372036854775807\" , \"9223372036854775807\" ], \"region\" : \"EU863\" , \"hwspec\" : \"sx1301/1\" , \"freq_range\" :[ 863000000 , 870000000 ], \"DRs\" :[[ 11 , 125 , 0 ],[ 10 , 125 , 0 ],[ 9 , 125 , 0 ],[ 8 , 125 , 0 ],[ 7 , 125 , 0 ],[ 7 , 250 , 0 ]], \"sx1301_conf\" :[{ \"radio_0\" :{ \"enable\" : true , \"freq\" : 867500000 }, \"radio_1\" :{ \"enable\" : true , \"freq\" : 868500000 }, \"chan_FSK\" :{ \"enable\" : true , \"radio\" : 1 , \"if\" : 300000 }, \"chan_Lora_std\" :{ \"enable\" : true , \"radio\" : 1 , \"if\" : -200000 , \"bandwidth\" : 250000 , \"spread_factor\" : 7 }, \"chan_multiSF_0\" :{ \"enable\" : true , \"radio\" : 1 , \"if\" : -400000 }, \"chan_multiSF_1\" :{ \"enable\" : true , \"radio\" : 1 , \"if\" : -200000 }, \"chan_multiSF_2\" :{ \"enable\" : true , \"radio\" : 1 , \"if\" : 0 }, \"chan_multiSF_3\" :{ \"enable\" : true , \"radio\" : 0 , \"if\" : -400000 }, \"chan_multiSF_4\" :{ \"enable\" : true , \"radio\" : 0 , \"if\" : -200000 }, \"chan_multiSF_5\" :{ \"enable\" : true , \"radio\" : 0 , \"if\" : 0 }, \"chan_multiSF_6\" :{ \"enable\" : true , \"radio\" : 0 , \"if\" : 200000 }, \"chan_multiSF_7\" :{ \"enable\" : true , \"radio\" : 0 , \"if\" : 400000 }}], \"nocca\" : true , \"nodc\" : true , \"nodwell\" : true } Assuming that we do not choose a different representation (e.g. compression, sharing of duplicated parts of the document) we can safely guarantee that we support 30 gateways per network server with this approach. NB : In case the specification requires us to transfer 64-bit numbers (e.g. for EUIs), we either need to split up such a number into two 32-bit numbers or represent it as a string. Device twins encode numbers as 32-bit values. Advantages : We can fetch the LBS configuration needing to have access to the contentrator device key (as in Option 3). No need to create additional IoT devices for each LBS. Configuration of all LBSs is centralized in one place which would make it easier to find. Disadvantages : The centralization of configuration complicates the changes needed to connect to other or multiple LNSs (for dynamic discovery or resiliency purposes) The limit of ~30 LBSs per LNS is considered enough for now (initially we considered 4-5 LBSs per LNS) but could be limiting in the future especially if the twins grow. Workarounds can be considered e.g. use this space only for non-default LBSs or potentially compress.","title":"Option 2: Hold LBS configurations in the LNS module twin"},{"location":"adr/002_lbs_configuration/#option-3-track-each-lbs-as-separate-iot-hub-device","text":"In this option, we create IoT Hub devices (not edge-enabled) for every LBS. The configuration of LBS is held in the device twin. Open question : Do we allow an LNS to get info for any LBS or only for the ones that are connected to it?","title":"Option 3: Track each LBS as separate IoT Hub device"},{"location":"adr/002_lbs_configuration/#lns-uses-the-azure-function-to-retrieve-the-device-key","text":"LBS requests its configuration passing its device id. LNS invokes the existing Azure Function to get the Device key passing the LBS id. The Function returns the Device Key (via a cache or by querying IoT Hub). LNS uses the Device Key to impersonate LBS, get its twin that holds the configuration (optionally: listens to future updates to it by DeviceClient.SetDesiredPropertyUpdateCallbackAsync ). Notes: Code changes are not extensive, as most of the code change is already there Advantages : LBSs are self-contained and therefore can be moved more easily for example to a different LNS (discovery phase) or connect to more than one LNS (resiliency). Disadvantages : We would need to provision and manage IoT devices for LBSs. More complex LNS flow since it involves the Function. Possible delay, though there is no timeout window within which we need to respond. Multiple open connections are required for each LBS.","title":"LNS uses the Azure Function to retrieve the device key"},{"location":"adr/002_lbs_configuration/#alternative-1-utilize-the-child-parent-feature-to-avoid-invoking-additional-azure-services","text":"By establishing a child-parent relationship between LBSs and LNS, messages from and to LBS are passed transparently through the LNS. The idea here would be that LNS as the parent, has access to the LBS device twin without the need to use the LBS device key. Reason for disqualifying: There seems that there is no API in either the DeviceClient nor the ModuleClient to retrieve the device twin of a child without having the device key.","title":"Alternative 1: utilize the child-parent feature to avoid invoking additional Azure services"},{"location":"adr/002_lbs_configuration/#alternative-2-edge-enabled-lbs-sends-upstream-its-twin-to-lns","text":"If LBS was an IoT Edge enabled device, we could utilize ModuleClient.SetDesiredPropertyUpdateCallbackAsync to send upstream to its parent the updated module twin. LNS could filter messages coming from downstream/child devices based on whether they contain a module id or not to get a hold of this configuration. Reason for disqualifying: Given that LBS needs to run on low powered devices, we can not change them to IoT Edge enabled devices.","title":"Alternative 2: edge-enabled LBS sends upstream its twin to LNS"},{"location":"adr/002_lbs_configuration/#decision","text":"Based on this investigation and the team discussion, Option 3 was chosen due to the flexibility it offers in terms of use-cases (resiliency, dynamic discovery) as well as scaling options. The additional complexity is deemed reasonable given the additional future-proofness.","title":"Decision"},{"location":"adr/003_documentation/","text":"003. Documentation Feature : #700 Authors : Roel Fauconnier Status : Proposes Overview / Problem Statement Currently the documentation is not very well structured, and content is hard to discover. There is no search except for the built-in GitHub code search. Some of the documentation is spread out across different files. We want to bring the documentation up-to-date and make it more discoverable. Proposed solution Use GitHub Pages . GitHub has a \"Pages\" functionality which allows you to publish a static website to a predefined URL: https://projectname.github.io . It can be published from a branch and/or folder. The folders are limited to / or /docs . The best practice seems to be to create a detached branch or git subtree called gh-pages which contains only the static website in a /docs folder. Use DocFX static site generator . DocFX is an open source tool provided by Microsoft that allows you to generate a static website based on a set of markdown files. Additionally, it can build documentation for a codebase based on the \"triple slash\" comments ( /// ) in .NET code. It uses yaml files to provide structure to the documentation. There is no built-in support in GitHub, but there are already some GitHub Actions available to help automate the publishing of docs. However, we will not use the code documentation feature of DocFX, since the code does not represent an API. Create a detached branch to keep all docs , called docs/main . This keeps history out of the main code repository, and allows for changes to the documentation without triggering any tag, version or CI. Create a detached branch to keep static site , called gh-pages . This allows for a place where the docs can be published from. Versioning : the tool mike is used for managing the versions. Two different workflows will manage the deployment: CI for each push to docs/main will automatically deploy version called dev Manual workflow with parameter for version will deploy that version, set it to latest and additionally tag the repo with docs@<version> Open Questions [x] Can multiple branches be locked in GitHub? E.g. ideally docs/main will be locked and can only be updated through a PR. YES - it is possible to add rules to different branches. Alternatives Considered Structurize the current folders Bring more structure to the current documentation folders, and use GitHub \"markdown-preview\" feature. The docs can be searched via GitHub search function. This also means adding additional links from each document to other documents to make things more discoverable. Use Jekyll static site generator Jekyll is the default option that Github provides to generate a static website. There are Github Actions available to help you build and publish the static website. Jekyll requires you to add specific yaml snippets to your documentation to be able to build a static site. Also, it is not fully supported on Windows right now . Use a different repository for the docs While this is a solution for some OSS repositories, it is overkill for this one. Additionally, it may be hard to open a new repository within the Azure organization. here is a code sample example code 1 2 3 4 5 6 7 namespace hello { public class world { public world (){ } } }","title":"003. Documentation"},{"location":"adr/003_documentation/#003-documentation","text":"Feature : #700 Authors : Roel Fauconnier Status : Proposes","title":"003. Documentation"},{"location":"adr/003_documentation/#overview-problem-statement","text":"Currently the documentation is not very well structured, and content is hard to discover. There is no search except for the built-in GitHub code search. Some of the documentation is spread out across different files. We want to bring the documentation up-to-date and make it more discoverable.","title":"Overview / Problem Statement"},{"location":"adr/003_documentation/#proposed-solution","text":"Use GitHub Pages . GitHub has a \"Pages\" functionality which allows you to publish a static website to a predefined URL: https://projectname.github.io . It can be published from a branch and/or folder. The folders are limited to / or /docs . The best practice seems to be to create a detached branch or git subtree called gh-pages which contains only the static website in a /docs folder. Use DocFX static site generator . DocFX is an open source tool provided by Microsoft that allows you to generate a static website based on a set of markdown files. Additionally, it can build documentation for a codebase based on the \"triple slash\" comments ( /// ) in .NET code. It uses yaml files to provide structure to the documentation. There is no built-in support in GitHub, but there are already some GitHub Actions available to help automate the publishing of docs. However, we will not use the code documentation feature of DocFX, since the code does not represent an API. Create a detached branch to keep all docs , called docs/main . This keeps history out of the main code repository, and allows for changes to the documentation without triggering any tag, version or CI. Create a detached branch to keep static site , called gh-pages . This allows for a place where the docs can be published from. Versioning : the tool mike is used for managing the versions. Two different workflows will manage the deployment: CI for each push to docs/main will automatically deploy version called dev Manual workflow with parameter for version will deploy that version, set it to latest and additionally tag the repo with docs@<version>","title":"Proposed solution"},{"location":"adr/003_documentation/#open-questions","text":"[x] Can multiple branches be locked in GitHub? E.g. ideally docs/main will be locked and can only be updated through a PR. YES - it is possible to add rules to different branches.","title":"Open Questions"},{"location":"adr/003_documentation/#alternatives-considered","text":"Structurize the current folders Bring more structure to the current documentation folders, and use GitHub \"markdown-preview\" feature. The docs can be searched via GitHub search function. This also means adding additional links from each document to other documents to make things more discoverable. Use Jekyll static site generator Jekyll is the default option that Github provides to generate a static website. There are Github Actions available to help you build and publish the static website. Jekyll requires you to add specific yaml snippets to your documentation to be able to build a static site. Also, it is not fully supported on Windows right now . Use a different repository for the docs While this is a solution for some OSS repositories, it is overkill for this one. Additionally, it may be hard to open a new repository within the Azure organization. here is a code sample example code 1 2 3 4 5 6 7 namespace hello { public class world { public world (){ } } }","title":"Alternatives Considered"},{"location":"adr/004_region_as923_implementation/","text":"004. Region AS923 implementation Milestone / Epic: #412 Authors: Maggie Salak Overview / Problem Statement The specification of region AS923 defines a AS923_FREQ_OFFSET parameter which is used to accommodate different country-specific sub-bands across the 915 - 928 MHz band. The parameter can have one of four different values depending on a country. The corresponding frequency offset in Hz is AS923_FREQ_OFFSET_HZ = 100 x AS923_FREQ_OFFSET . The value of the parameter is needed for the purpose of calculating RX2 window frequencies for AS923 region. The parameter is not required for calculating RX1 receive window as it simply uses the same channel as the preceding uplink. This document summarizes decisions taken for the purpose of implementing support for region AS923. In-Scope Support for all countries using frequency plan AS923 Calculation of RX1 downstream frequencies and data rates Calculation of RX2 receive window Out-of-scope MAC commands - support will be added later on as part of #414 Adaptive Data Rate - support will be added later on as part of #415 DwellTime - it is not yet clear whether the parameter needs to be set or not, this is tracked in user story #732 FOpts - it is not yet clear whether this parameter needs to be used, this is tracked for all regions as part of user story #717 Decision The AS923_FREQ_OFFSET parameter can be calculated based on the channel 0 and channel 1 frequencies in the LoRa Basics Station configuration. The corresponding channels for region AS923 are defined as follows: Channel 0 frequency Hz = 923200000 + AS923_FREQ_OFFSET_HZ Channel 1 frequency Hz = 923400000 + AS923_FREQ_OFFSET_HZ Using this formula we will calculate the offset by subtracting 923200000 from the configured channel 0 frequency. We will use the formula for channel 1 frequency to validate the offset value and throw and exception if values are not the same. In the implementation of region AS923 the frequencies for channel 0 and 1 will be passed to the region-specific constructor where the offset value will be calculated.","title":"004. Region AS923 implementation"},{"location":"adr/004_region_as923_implementation/#004-region-as923-implementation","text":"Milestone / Epic: #412 Authors: Maggie Salak","title":"004. Region AS923 implementation"},{"location":"adr/004_region_as923_implementation/#overview-problem-statement","text":"The specification of region AS923 defines a AS923_FREQ_OFFSET parameter which is used to accommodate different country-specific sub-bands across the 915 - 928 MHz band. The parameter can have one of four different values depending on a country. The corresponding frequency offset in Hz is AS923_FREQ_OFFSET_HZ = 100 x AS923_FREQ_OFFSET . The value of the parameter is needed for the purpose of calculating RX2 window frequencies for AS923 region. The parameter is not required for calculating RX1 receive window as it simply uses the same channel as the preceding uplink. This document summarizes decisions taken for the purpose of implementing support for region AS923.","title":"Overview / Problem Statement"},{"location":"adr/004_region_as923_implementation/#in-scope","text":"Support for all countries using frequency plan AS923 Calculation of RX1 downstream frequencies and data rates Calculation of RX2 receive window","title":"In-Scope"},{"location":"adr/004_region_as923_implementation/#out-of-scope","text":"MAC commands - support will be added later on as part of #414 Adaptive Data Rate - support will be added later on as part of #415 DwellTime - it is not yet clear whether the parameter needs to be set or not, this is tracked in user story #732 FOpts - it is not yet clear whether this parameter needs to be used, this is tracked for all regions as part of user story #717","title":"Out-of-scope"},{"location":"adr/004_region_as923_implementation/#decision","text":"The AS923_FREQ_OFFSET parameter can be calculated based on the channel 0 and channel 1 frequencies in the LoRa Basics Station configuration. The corresponding channels for region AS923 are defined as follows: Channel 0 frequency Hz = 923200000 + AS923_FREQ_OFFSET_HZ Channel 1 frequency Hz = 923400000 + AS923_FREQ_OFFSET_HZ Using this formula we will calculate the offset by subtracting 923200000 from the configured channel 0 frequency. We will use the formula for channel 1 frequency to validate the offset value and throw and exception if values are not the same. In the implementation of region AS923 the frequencies for channel 0 and 1 will be passed to the region-specific constructor where the offset value will be calculated.","title":"Decision"},{"location":"adr/005_observability/","text":"005 - Observability Date : 2021-11-08 Participants : Patrick Schuler, Bastian Burger, Eugene Fedorenko Status Accepted Context The goal of observability for the LoRaWAN IoT Edge starter kit is to: Monitor if the LoRaWAN Starter Kit solution works according to the user expectations regarding the following factors: Coverage. The data is coming from the majority of observed IoT assets Freshness. The data coming from the assets is fresh and relevant Throughput. The data is delivered from the assets without significant delays. Correctness. The ratio of errors and lost messages from the assets is small Provide monitoring instruments to detect possible failure/violation in each factor Provide instruments to identify and diagnose failures to get to the problem quickly The decisions in the following will apply to our LoRaWAN Network Server (LNS) implementation. Decisions We will support Azure Monitor as a first-class monitoring solution for our starter kit. A user can opt-in to use Application Insights with the starter kit, in which case we will support a rich set of observability features. If the user decides to not use Application Insights, we will still support essential monitoring capabilities. This means that we will: Track LNS logs in Application Insights (when opted in). We will adhere to the IoT Edge recommended format for the structure of the log console output. Export of logs to anything else than Application Insights requires a custom solution by the user and is not supported by the starter kit. Always expose metrics using prometheus-net . Additionally, we track LNS metrics using the ASP.NET Core Application Insights SDK (when opted in) Track traces using the Application Insights SDK (when opted in) Support alerts when using Application Insights and/or Log Analytics (with Prometheus format and metrics collector module) For now we will not support complete distributed tracing in the LoRaWAN starter kit, other than what Application Insights tracing will give us out of the box. We will evaluate this with #695 . A more thorough description of each bullet point follows below. Logs Using ILogger as the core method to log information from all parts of the application makes sure we have an abstracted logging framework we can use and can add/remove sinks as required. The different log sinks are implemented as ILoggerProvider . We will have three to start with: Console IoT Hub TCP The standard logger for Application Insights is added on an opt-in basis. We will adhere to the recommended logging format for the LNS console logger to comply with the IoT Edge log format and to simplify logs scraping. We will not support a full logs delivery solution, such as ELMS , since it will introduce too many components and too much complexity to the starter kit. This means that we will not support cloud delivery of edgeAgent and edgeHub logs other than what is documented in Retrieve IoT Edge logs - Azure IoT Edge | Microsoft Docs . If a user of the starter kit wants to scrape logs from modules other than LNS, or use a service other than the Application Insights SDK, the user will have to implement a custom solution. Traces We use built-in tracing from Azure Application Insights (on an opt-in basis). This works well for function calls and correlation to other services, such as Key Vault. We will not include message flow end to end tracing for now, but will reevaluate with #695 . Metrics The core modules edgeHub and edgeAgent support emitting metrics through a Prometheus endpoint, using the strategy described in Access built-in metrics - Azure IoT Edge | Microsoft Docs . To collect these metrics and integrate everything with Azure Monitor, we use the metric collector (preview) as suggested in Collect and transport metrics - Azure IoT Edge | Microsoft Docs to export metrics to a Log Analytics storage. We will always expose LNS custom metrics in Prometheus format using prometheus-net/prometheus-net , such that they can be consumed by any scraper that supports the Prometheus format. This will give us the following features: Unified metrics format accross all modules in the Edge device. The Prometheus format is industrial standard understood by various consumers. Decouples metrics exposure from the delivery-to-cloud approach. If at one point we decide to change how we scrap the metrics or how/where we deliver them to the observer, we can do that without changing the modules. Eliminates any dependencies on Azure Monitor services (Log Analytics / Application Insights) for essential monitoring Potentially gives ability to work offline if metrics are sent by the collector module through the Edge Hub using device-to-cloud channel. It's up to the customer to configure how, where and what metrics to deliver from any module on an edge device. In addition to this, we will support Application Insights metrics on an opt-in basis. When enabled, we will deliver most metrics (custom and default from LNS, except the edgeAgent and edgeHub metrics, which can only be delivered to Log Analytics) to Application Insights. This will ensure that we get many of the features that we get with Application Insights out of the box (Live Metrics, integration with alerts and workbooks), while still keeping the flexibility of consuming the metrics in Prometheus format and all the advantages that come with it. This comes at the cost of increased implementation complexity. Note: IoT Hub comes with curated workbooks and predefined queries for alerts based on built-in Prometheus-format metrics that are delivered by the metrics collector module to LogAnalytics. Custom metrics/events Name Description Source Namespace Dimensions RxWndRate Number of times we hit the different receive windows. LNS LoRaWan Gateway Id, Receive Window RxWndMiss Number of missed on downstream windows LNS LoRaWan Gateway Id DeviceCacheHit Number of device cache hit LNS LoRaWan Gateway Id DeviceLoadRequests Number of device load requests LNS LoRaWan Gateway Id JoinRequests Number of join requests LNS LoRaWan Gateway Id StationConnectivityLost Connection to LBS lost LNS LoRaWan Gateway Id ActiveStationConnections Active connections to stations LNS LoRaWan Gateway Id D2CMessagesReceived Number of messages received from device LNS LoRaWan Gateway Id D2CMessageDeliveryLatency Time from when we received the message from the concentrator until we are done processing it LNS LoRaWan Gateway Id D2CMessagesDelivered Number of messages sent to upstream LNS LoRaWan Gateway Id, To D2CMessagesError Number of errors in sending messages to upstream LNS LoRaWan Gateway Id, To D2CMessagesProcessingError Number of errors processing (decoding, decrypting) messages LNS LoRaWan Gateway Id, To D2CMessageSize Message size in bytes received from device LNS LoRaWan Gateway Id D2CMessageSizeUpstream Message size in bytes sent upstream LNS LoRaWan Gateway Id, To C2DMessagesAbandoned Number of C2D messages abandoned LNS LoRaWan Gateway Id C2DMessagesDelivered Number of messages sent downstream LNS LoRaWan Gateway Id, To C2DMessagesError Number of errors in sending messages to downstream LNS LoRaWan Gateway Id, To C2DMessageSizeDownstream Message size in bytes sent downstream LNS LoRaWan Gateway Id, To Alerts We support the following alerts when the user opts in to use Application Insights. Name Description Source Condition HighUpstreamMessageLatency High device message processing time (throughput) D2CMessageDeliveryLatency Dynamic HighUpstreamMessageErrorRatio High device messages error ratio (correctness) D2CMessagesError Dynamic HighUpstreamMessagesLostRatio High device messages lost ratio (correctness, throughput) D2CMessagesReceived/D2CMessagesDelivered Dynamic HighDownstreamMessageLatency High device message processing time (throughput) RxWndMiss Dynamic HighDownstreamMessageErrorRatio High device messages error ratio (correctness) D2CMessagesError Dynamic HighDownstreamMessagesLostRatio High device messages lost ratio (correctness, throughput) C2DMessagesAbandoned Dynamic Alternatives considered As a generic alternative to the Application Insights SDK we considered the OpenTelemetry .NET SDK. This would allow us to abstract emitting telemetry for different backend systems. However, the status of the project - open-telemetry/opentelemetry-dotnet: The OpenTelemetry .NET Client (github.com) - is not ready to be added to the Starter Kit. Especially Prometheus exporter (alpha) and metrics in general (experimental) do not help us improving our solution at the moment.","title":"005 - Observability"},{"location":"adr/005_observability/#005-observability","text":"Date : 2021-11-08 Participants : Patrick Schuler, Bastian Burger, Eugene Fedorenko","title":"005 - Observability"},{"location":"adr/005_observability/#status","text":"Accepted","title":"Status"},{"location":"adr/005_observability/#context","text":"The goal of observability for the LoRaWAN IoT Edge starter kit is to: Monitor if the LoRaWAN Starter Kit solution works according to the user expectations regarding the following factors: Coverage. The data is coming from the majority of observed IoT assets Freshness. The data coming from the assets is fresh and relevant Throughput. The data is delivered from the assets without significant delays. Correctness. The ratio of errors and lost messages from the assets is small Provide monitoring instruments to detect possible failure/violation in each factor Provide instruments to identify and diagnose failures to get to the problem quickly The decisions in the following will apply to our LoRaWAN Network Server (LNS) implementation.","title":"Context"},{"location":"adr/005_observability/#decisions","text":"We will support Azure Monitor as a first-class monitoring solution for our starter kit. A user can opt-in to use Application Insights with the starter kit, in which case we will support a rich set of observability features. If the user decides to not use Application Insights, we will still support essential monitoring capabilities. This means that we will: Track LNS logs in Application Insights (when opted in). We will adhere to the IoT Edge recommended format for the structure of the log console output. Export of logs to anything else than Application Insights requires a custom solution by the user and is not supported by the starter kit. Always expose metrics using prometheus-net . Additionally, we track LNS metrics using the ASP.NET Core Application Insights SDK (when opted in) Track traces using the Application Insights SDK (when opted in) Support alerts when using Application Insights and/or Log Analytics (with Prometheus format and metrics collector module) For now we will not support complete distributed tracing in the LoRaWAN starter kit, other than what Application Insights tracing will give us out of the box. We will evaluate this with #695 . A more thorough description of each bullet point follows below.","title":"Decisions"},{"location":"adr/005_observability/#logs","text":"Using ILogger as the core method to log information from all parts of the application makes sure we have an abstracted logging framework we can use and can add/remove sinks as required. The different log sinks are implemented as ILoggerProvider . We will have three to start with: Console IoT Hub TCP The standard logger for Application Insights is added on an opt-in basis. We will adhere to the recommended logging format for the LNS console logger to comply with the IoT Edge log format and to simplify logs scraping. We will not support a full logs delivery solution, such as ELMS , since it will introduce too many components and too much complexity to the starter kit. This means that we will not support cloud delivery of edgeAgent and edgeHub logs other than what is documented in Retrieve IoT Edge logs - Azure IoT Edge | Microsoft Docs . If a user of the starter kit wants to scrape logs from modules other than LNS, or use a service other than the Application Insights SDK, the user will have to implement a custom solution.","title":"Logs"},{"location":"adr/005_observability/#traces","text":"We use built-in tracing from Azure Application Insights (on an opt-in basis). This works well for function calls and correlation to other services, such as Key Vault. We will not include message flow end to end tracing for now, but will reevaluate with #695 .","title":"Traces"},{"location":"adr/005_observability/#metrics","text":"The core modules edgeHub and edgeAgent support emitting metrics through a Prometheus endpoint, using the strategy described in Access built-in metrics - Azure IoT Edge | Microsoft Docs . To collect these metrics and integrate everything with Azure Monitor, we use the metric collector (preview) as suggested in Collect and transport metrics - Azure IoT Edge | Microsoft Docs to export metrics to a Log Analytics storage. We will always expose LNS custom metrics in Prometheus format using prometheus-net/prometheus-net , such that they can be consumed by any scraper that supports the Prometheus format. This will give us the following features: Unified metrics format accross all modules in the Edge device. The Prometheus format is industrial standard understood by various consumers. Decouples metrics exposure from the delivery-to-cloud approach. If at one point we decide to change how we scrap the metrics or how/where we deliver them to the observer, we can do that without changing the modules. Eliminates any dependencies on Azure Monitor services (Log Analytics / Application Insights) for essential monitoring Potentially gives ability to work offline if metrics are sent by the collector module through the Edge Hub using device-to-cloud channel. It's up to the customer to configure how, where and what metrics to deliver from any module on an edge device. In addition to this, we will support Application Insights metrics on an opt-in basis. When enabled, we will deliver most metrics (custom and default from LNS, except the edgeAgent and edgeHub metrics, which can only be delivered to Log Analytics) to Application Insights. This will ensure that we get many of the features that we get with Application Insights out of the box (Live Metrics, integration with alerts and workbooks), while still keeping the flexibility of consuming the metrics in Prometheus format and all the advantages that come with it. This comes at the cost of increased implementation complexity. Note: IoT Hub comes with curated workbooks and predefined queries for alerts based on built-in Prometheus-format metrics that are delivered by the metrics collector module to LogAnalytics.","title":"Metrics"},{"location":"adr/005_observability/#custom-metricsevents","text":"Name Description Source Namespace Dimensions RxWndRate Number of times we hit the different receive windows. LNS LoRaWan Gateway Id, Receive Window RxWndMiss Number of missed on downstream windows LNS LoRaWan Gateway Id DeviceCacheHit Number of device cache hit LNS LoRaWan Gateway Id DeviceLoadRequests Number of device load requests LNS LoRaWan Gateway Id JoinRequests Number of join requests LNS LoRaWan Gateway Id StationConnectivityLost Connection to LBS lost LNS LoRaWan Gateway Id ActiveStationConnections Active connections to stations LNS LoRaWan Gateway Id D2CMessagesReceived Number of messages received from device LNS LoRaWan Gateway Id D2CMessageDeliveryLatency Time from when we received the message from the concentrator until we are done processing it LNS LoRaWan Gateway Id D2CMessagesDelivered Number of messages sent to upstream LNS LoRaWan Gateway Id, To D2CMessagesError Number of errors in sending messages to upstream LNS LoRaWan Gateway Id, To D2CMessagesProcessingError Number of errors processing (decoding, decrypting) messages LNS LoRaWan Gateway Id, To D2CMessageSize Message size in bytes received from device LNS LoRaWan Gateway Id D2CMessageSizeUpstream Message size in bytes sent upstream LNS LoRaWan Gateway Id, To C2DMessagesAbandoned Number of C2D messages abandoned LNS LoRaWan Gateway Id C2DMessagesDelivered Number of messages sent downstream LNS LoRaWan Gateway Id, To C2DMessagesError Number of errors in sending messages to downstream LNS LoRaWan Gateway Id, To C2DMessageSizeDownstream Message size in bytes sent downstream LNS LoRaWan Gateway Id, To","title":"Custom metrics/events"},{"location":"adr/005_observability/#alerts","text":"We support the following alerts when the user opts in to use Application Insights. Name Description Source Condition HighUpstreamMessageLatency High device message processing time (throughput) D2CMessageDeliveryLatency Dynamic HighUpstreamMessageErrorRatio High device messages error ratio (correctness) D2CMessagesError Dynamic HighUpstreamMessagesLostRatio High device messages lost ratio (correctness, throughput) D2CMessagesReceived/D2CMessagesDelivered Dynamic HighDownstreamMessageLatency High device message processing time (throughput) RxWndMiss Dynamic HighDownstreamMessageErrorRatio High device messages error ratio (correctness) D2CMessagesError Dynamic HighDownstreamMessagesLostRatio High device messages lost ratio (correctness, throughput) C2DMessagesAbandoned Dynamic","title":"Alerts"},{"location":"adr/005_observability/#alternatives-considered","text":"As a generic alternative to the Application Insights SDK we considered the OpenTelemetry .NET SDK. This would allow us to abstract emitting telemetry for different backend systems. However, the status of the project - open-telemetry/opentelemetry-dotnet: The OpenTelemetry .NET Client (github.com) - is not ready to be added to the Starter Kit. Especially Prometheus exporter (alpha) and metrics in general (experimental) do not help us improving our solution at the moment.","title":"Alternatives considered"},{"location":"samples/arduino/","text":"Arduino Demo Code Please make sure the device twin tags are set correctly in IoT Hub, otherwise the sample won't work. Necessary tags are at the start of every sample file.ino. This samples were tested with the Seeeduino LoRaWan boards . The LoRaWan libraries (referenced thru \"LoRaWan.h\" in the ino files) is coming when you select the platform as a Seeduino LoRaWan board. If you are using another LoRaWan library, you will have to adjust this code as so far, all LoRaWan libraries are different from one manufacturer to another on Arduino platform. That said, adaptation shouldn't be too difficult and equivalent functions has to exist in all libraries. This samples were tested with the Seeeduino LoRaWan boards. Samples are organized by regions as LoRaWan uses different frequences based on your geography. Please make sure you're using the sample from the correct geography. TransmissionTestOTAALoRa - This is the most basic example. The sample perform an OTAA authentication and send a message to the gateway every 5 seconds. The sample also display on the serial interface any cloud to device message. TransmissionTestABPLoRa - Same functionality as 1. but it uses ABP instead of OTAA. GPSOTAALoRa - This sample sends GPS latitude and longitude information every 30 seconds using the onboard GPS. It uses OTAA activation. It uses OTAA activation to authenticate. 34 TemperatureOTAALoRa - This sample use the Grove temperature sensor to send temperature information every 30 seconds. It uses OTAA activation to authenticate. The sample also display on the serial interface any cloud to device message.","title":"Arduino Demo Code"},{"location":"samples/arduino/#arduino-demo-code","text":"Please make sure the device twin tags are set correctly in IoT Hub, otherwise the sample won't work. Necessary tags are at the start of every sample file.ino. This samples were tested with the Seeeduino LoRaWan boards . The LoRaWan libraries (referenced thru \"LoRaWan.h\" in the ino files) is coming when you select the platform as a Seeduino LoRaWan board. If you are using another LoRaWan library, you will have to adjust this code as so far, all LoRaWan libraries are different from one manufacturer to another on Arduino platform. That said, adaptation shouldn't be too difficult and equivalent functions has to exist in all libraries. This samples were tested with the Seeeduino LoRaWan boards. Samples are organized by regions as LoRaWan uses different frequences based on your geography. Please make sure you're using the sample from the correct geography. TransmissionTestOTAALoRa - This is the most basic example. The sample perform an OTAA authentication and send a message to the gateway every 5 seconds. The sample also display on the serial interface any cloud to device message. TransmissionTestABPLoRa - Same functionality as 1. but it uses ABP instead of OTAA. GPSOTAALoRa - This sample sends GPS latitude and longitude information every 30 seconds using the onboard GPS. It uses OTAA activation. It uses OTAA activation to authenticate. 34 TemperatureOTAALoRa - This sample use the Grove temperature sensor to send temperature information every 30 seconds. It uses OTAA activation to authenticate. The sample also display on the serial interface any cloud to device message.","title":"Arduino Demo Code"},{"location":"samples/decoders/cayenne/","text":"Cayenne Decoder This sample allows you to create and run your own LoRa message decoder in an independent container running on your LoRa gateway without having to edit the main LoRa Engine. It is based on the sample decoder. How to use the sample decoder This decode takes a Lora payload and decode it based on the Cayenne encoding specification . The payload is decoded and transformed into a json object. The payload AWcA5gJoMANzJigEZQD9 will then be transformed as: { \"value\" :{ \"IlluminanceSensor\" :[{ \"Channel\" : 4 , \"Value\" : 253 }], \"TemperatureSensor\" :[{ \"Channel\" : 1 , \"Value\" : 23.0 }], \"HumiditySensor\" :[{ \"Channel\" : 2 , \"Value\" : 24.0 }], \"Barometer\" :[{ \"Channel\" : 3 , \"Value\" : 976.8 }]}} You can build the docker image or use the module.json file to build an iot edge module. You can then use the following command to start the module: docker run --rm -it -p 8881 :80 your.azurecr.io/cayennedecoder:tag You can then submit the payload from the example here above by hitting the following URL: http://yourhost:8881/api/CayenneDecoder?fport=1&payload=AWcA5gJoMANzJigEZQD9 Supported Cayenne devices All Cayenne devices are supported.","title":"Cayenne Decoder"},{"location":"samples/decoders/cayenne/#cayenne-decoder","text":"This sample allows you to create and run your own LoRa message decoder in an independent container running on your LoRa gateway without having to edit the main LoRa Engine. It is based on the sample decoder.","title":"Cayenne Decoder"},{"location":"samples/decoders/cayenne/#how-to-use-the-sample-decoder","text":"This decode takes a Lora payload and decode it based on the Cayenne encoding specification . The payload is decoded and transformed into a json object. The payload AWcA5gJoMANzJigEZQD9 will then be transformed as: { \"value\" :{ \"IlluminanceSensor\" :[{ \"Channel\" : 4 , \"Value\" : 253 }], \"TemperatureSensor\" :[{ \"Channel\" : 1 , \"Value\" : 23.0 }], \"HumiditySensor\" :[{ \"Channel\" : 2 , \"Value\" : 24.0 }], \"Barometer\" :[{ \"Channel\" : 3 , \"Value\" : 976.8 }]}} You can build the docker image or use the module.json file to build an iot edge module. You can then use the following command to start the module: docker run --rm -it -p 8881 :80 your.azurecr.io/cayennedecoder:tag You can then submit the payload from the example here above by hitting the following URL: http://yourhost:8881/api/CayenneDecoder?fport=1&payload=AWcA5gJoMANzJigEZQD9","title":"How to use the sample decoder"},{"location":"samples/decoders/cayenne/#supported-cayenne-devices","text":"All Cayenne devices are supported.","title":"Supported Cayenne devices"},{"location":"samples/decoders/decoder/","text":"DecoderSample This sample allows you to create and run your own LoRa message decoder in an independent container running on your LoRa gateway without having to edit the main LoRa Engine. This description shows you how to get started. Customizing To add a new decoder, simply copy or reuse the sample DecoderValueSensor method from the LoraDecoders class in LoraDecoder.cs . You can name the method whatever you like and can create as many decoders as you need by adding new, individual methods to the LoraDecoders class. The payload sent to the decoder is passed as string devEui , byte[] payload and uint fport . After writing the code that decodes your message, your method should return a string containing valid JSON containing the response to be sent upstream. internal static class LoraDecoders { private static string DecoderValueSensor(string devEUI, byte[] payload, byte fport) { // EITHER: Convert a payload containing a string back to string format for further processing var result = Encoding.UTF8.GetString(payload); // OR: Convert a payload containing binary data to HEX string for further processing var result_binary = ConversionHelper.ByteArrayToString(payload); // Write code that decodes the payload here. // Return a JSON string containing the decoded data return JsonConvert.SerializeObject(new { value = result }); } } You can test the decoder on your machine by debugging the SensorDecoderModule project in Visual Studio. When creating a debugging configuration in Visual Studio Code or a launchSettings.json file in Visual Studio, the default address that the webserver will try to use is http://localhost:5000 or https://localhost:5001 . You can override this with any port of your choice. On launching the debugger you will see a webbrowser with a 404 Not Found error as there is no default document to be served in this Web API app. You will also manually need to base64-encode and URL-encode the payload before adding it to the URL parameters. For example, to test a payload of ABCDE12345 , you: Convert it to a base64 encoded string: QUJDREUxMjM0NQ== Convert the result to a valid URL parameter: QUJDREUxMjM0NQ%3D%3D Add this to your test URL. For the built-in sample decoder DecoderValueSensor with Visual Studio (Code)'s default settings this would be: http://localhost:5000/api/DecoderValueSensor?devEui=0000000000000000&fport=1&payload=QUJDREUxMjM0NQ%3D%3D You can call your decoder at: http://localhost:yourPort/api/<decodername>?devEui=0000000000000000&fport=1&payload=<QUJDREUxMjM0NQ%3D%3D> You should see the result as JSON string. When running the solution in a container, the Kestrel webserver from .NET Core uses the HTTP default port 80 of the container and does not need to bind it to a port on the host machine as Docker allows for container-to-container communication. IoT Edge automatically creates the required Docker Network Bridge . Preparing and Testing the Docker Image Create a docker image from your finished solution based on the target architecture and host it in an Azure Container Registry , on DockerHub or in any other container registry of your choice. We are using the Azure IoT Edge for Visual Studio Code extension to build and push the Docker image. Make sure you are logged in to the Azure Container Registry you are using. Run docker login <mycontainerregistry>.azurecr.io on your development machine. Edit the file module.json to contain your container registry address, image name and version number: We provide the Dockerfiles for the following architectures: Dockerfile.amd64 Dockerfile.arm32v7 To build the Docker image, right-click on the module.json file and select \"Build IoT Edge Module Image\" or \"Build and Push IoT Edge Module Image\". Select the architecture you want to build for (ARM32v7 or AMD64) from the drop-down menu. To temporarily test the container running you decoder using a webbrowser or Postman, you can manually start it in Docker and bind the container's port 80 to a free port on your host machine, like for example 8881. docker run --rm -it -p 8881 :80 --name decodersample <container registry>/<image>:<tag> ```` You can then use a browser to navigate to: http://localhost:8881/api/DecoderValueSensor?devEui=0000000000000000&fport=1&payload=QUJDREUxMjM0NQ%3D%3D ### Deploying to IoT Edge If required, add credentials to access your container registry to the IoT Edge device by adding them to IoT Hub &rarr; IoT Edge &rarr; Your Device &rarr; Set Modules &rarr; Container Registry settings. ![Decoder Sample - Edge Module Container Registry Permission](../../images/decodersample-edgepermission.png) Configure your IoT Edge gateway device to include the custom container. IoT Hub &rarr; IoT Edge &rarr; Your Device &rarr; Set Modules &rarr; Deployment Modules &rarr; Add &rarr; IoT Edge Module. Set the module Name and Image URI, pointing to your image created above. **Make sure to choose all lowercase letters for the Module Name as the container will be unreachable otherwise!** ![Decoder Sample - Edge Module](../../images/decodersample-edgemodule.png) To activate the decoder for a LoRa device, navigate to your IoT Hub &rarr; IoT Devices &rarr; Device Details &rarr; Device Twin and set the ```SensorDecoder``` value in the desired properties to: http:// /api/ ``` Again make sure to chosse all lowercase letters for the module name to make sure it is reachable. In case the custom decoder is unreachable, throws an error or return invalid JSON, the error message will be shown in your device's messages in IoT Hub.","title":"Decoder"},{"location":"samples/decoders/decoder/#decodersample","text":"This sample allows you to create and run your own LoRa message decoder in an independent container running on your LoRa gateway without having to edit the main LoRa Engine. This description shows you how to get started.","title":"DecoderSample"},{"location":"samples/decoders/decoder/#customizing","text":"To add a new decoder, simply copy or reuse the sample DecoderValueSensor method from the LoraDecoders class in LoraDecoder.cs . You can name the method whatever you like and can create as many decoders as you need by adding new, individual methods to the LoraDecoders class. The payload sent to the decoder is passed as string devEui , byte[] payload and uint fport . After writing the code that decodes your message, your method should return a string containing valid JSON containing the response to be sent upstream. internal static class LoraDecoders { private static string DecoderValueSensor(string devEUI, byte[] payload, byte fport) { // EITHER: Convert a payload containing a string back to string format for further processing var result = Encoding.UTF8.GetString(payload); // OR: Convert a payload containing binary data to HEX string for further processing var result_binary = ConversionHelper.ByteArrayToString(payload); // Write code that decodes the payload here. // Return a JSON string containing the decoded data return JsonConvert.SerializeObject(new { value = result }); } } You can test the decoder on your machine by debugging the SensorDecoderModule project in Visual Studio. When creating a debugging configuration in Visual Studio Code or a launchSettings.json file in Visual Studio, the default address that the webserver will try to use is http://localhost:5000 or https://localhost:5001 . You can override this with any port of your choice. On launching the debugger you will see a webbrowser with a 404 Not Found error as there is no default document to be served in this Web API app. You will also manually need to base64-encode and URL-encode the payload before adding it to the URL parameters. For example, to test a payload of ABCDE12345 , you: Convert it to a base64 encoded string: QUJDREUxMjM0NQ== Convert the result to a valid URL parameter: QUJDREUxMjM0NQ%3D%3D Add this to your test URL. For the built-in sample decoder DecoderValueSensor with Visual Studio (Code)'s default settings this would be: http://localhost:5000/api/DecoderValueSensor?devEui=0000000000000000&fport=1&payload=QUJDREUxMjM0NQ%3D%3D You can call your decoder at: http://localhost:yourPort/api/<decodername>?devEui=0000000000000000&fport=1&payload=<QUJDREUxMjM0NQ%3D%3D> You should see the result as JSON string. When running the solution in a container, the Kestrel webserver from .NET Core uses the HTTP default port 80 of the container and does not need to bind it to a port on the host machine as Docker allows for container-to-container communication. IoT Edge automatically creates the required Docker Network Bridge .","title":"Customizing"},{"location":"samples/decoders/decoder/#preparing-and-testing-the-docker-image","text":"Create a docker image from your finished solution based on the target architecture and host it in an Azure Container Registry , on DockerHub or in any other container registry of your choice. We are using the Azure IoT Edge for Visual Studio Code extension to build and push the Docker image. Make sure you are logged in to the Azure Container Registry you are using. Run docker login <mycontainerregistry>.azurecr.io on your development machine. Edit the file module.json to contain your container registry address, image name and version number: We provide the Dockerfiles for the following architectures: Dockerfile.amd64 Dockerfile.arm32v7 To build the Docker image, right-click on the module.json file and select \"Build IoT Edge Module Image\" or \"Build and Push IoT Edge Module Image\". Select the architecture you want to build for (ARM32v7 or AMD64) from the drop-down menu. To temporarily test the container running you decoder using a webbrowser or Postman, you can manually start it in Docker and bind the container's port 80 to a free port on your host machine, like for example 8881. docker run --rm -it -p 8881 :80 --name decodersample <container registry>/<image>:<tag> ```` You can then use a browser to navigate to: http://localhost:8881/api/DecoderValueSensor?devEui=0000000000000000&fport=1&payload=QUJDREUxMjM0NQ%3D%3D ### Deploying to IoT Edge If required, add credentials to access your container registry to the IoT Edge device by adding them to IoT Hub &rarr; IoT Edge &rarr; Your Device &rarr; Set Modules &rarr; Container Registry settings. ![Decoder Sample - Edge Module Container Registry Permission](../../images/decodersample-edgepermission.png) Configure your IoT Edge gateway device to include the custom container. IoT Hub &rarr; IoT Edge &rarr; Your Device &rarr; Set Modules &rarr; Deployment Modules &rarr; Add &rarr; IoT Edge Module. Set the module Name and Image URI, pointing to your image created above. **Make sure to choose all lowercase letters for the Module Name as the container will be unreachable otherwise!** ![Decoder Sample - Edge Module](../../images/decodersample-edgemodule.png) To activate the decoder for a LoRa device, navigate to your IoT Hub &rarr; IoT Devices &rarr; Device Details &rarr; Device Twin and set the ```SensorDecoder``` value in the desired properties to: http:// /api/ ``` Again make sure to chosse all lowercase letters for the module name to make sure it is reachable. In case the custom decoder is unreachable, throws an error or return invalid JSON, the error message will be shown in your device's messages in IoT Hub.","title":"Preparing and Testing the Docker Image"},{"location":"samples/decoders/universal/","text":"Universal Decoder This project gives access to decoders in the TTN repo through a HTTP REST interface compliant with the LoraWan implementation in this repository. Codecs provided by TTN are stored in a well defined folder structure . The universal decoder copies the codec files into its docker image at build time for later use from the web application. As currently codecs are not implemented as node modules (see open issue ), these files were patched accordingly after being copied so that they can be imported and reused. Quick start Install node dependencies and copy/patch codecs from the TTN repository: npm install npm run codecs Create docker image (replace amd64 with the architecture of your choice) docker build . -f Dockerfile.amd64 -t universaldecoder Run docker image: docker run --rm -d -p 8080 :8080 universaldecoder Call the built-in DecoderValueSensor decoder at the following url. You should see the result as JSON string. http://localhost:8080/api/DecoderValueSensor?devEui=0000000000000000&fport=1&payload=QUJDREUxMjM0NQ%3D%3D Finally list all available decoders with the following url: http://localhost:8080/decoders You can finally call any other supported decoder at: http://localhost:8080/api/<decoder>?devEui=0000000000000000&fport=<fport>&payload=<payload> Local development Start local server npm start You can access the universal decoder at the url available in the output of the previous command. Run tests npm test Universal Decoder REST API The url accepted by the universal decoder follows the pattern: /api/<decoder>?devEui=<devEui>&fport=<fport>&payload=<payload> decoder This path parameter identifies the TTN decoder that will be used. You can get a list of all available decoders by calling the /decoders endpoint. devEui LoRaWan unique end-device identifier. fport LoRaWan Port field as integer value. payload Base64 and URL encoded payload to decode. For example, to test a payload of ABCDE12345 , you: Convert it to a base64 encoded string: QUJDREUxMjM0NQ== Convert the result to a valid URL parameter: QUJDREUxMjM0NQ%3D%3D Add this to your URL as the payload query parameter. Deploying to Azure IoT Edge Push docker image to registry Create a docker image from your finished solution based on the target architecture and host it in an Azure Container Registry , on DockerHub or in any other container registry of your choice. Install the Azure IoT Edge for Visual Studio Code extension to build and push the Docker image. Make sure you are logged in to the Azure Container Registry you are using. Run docker login <mycontainerregistry>.azurecr.io on your development machine, or az acr login -n mycontainerregistry if the Azure CLI is available. Edit the file module.json to contain your container registry address, image name and version number: We provide the Dockerfiles for the following architectures: Dockerfile.amd64 Dockerfile.arm32v7 Dockerfile.arm64v8 To build the Docker image, right-click on the module.json file and select \"Build IoT Edge Module Image\" or \"Build and Push IoT Edge Module Image\". Select the architecture you want to build for from the drop-down menu. To temporarily test the container running you decoder using a webbrowser or Postman, you can manually start it in Docker and bind the container's port 8080 to a free port on your host machine (8080 is usually good). docker run --rm -it -p 8080 :8080 --name universaldecoder <container registry>/<image>:<tag> ```` Call the built-in ` DecoderValueSensor ` decoder at the following url: http://localhost:8080/api/DecoderValueSensor?devEui=0000000000000000&fport=1&payload=QUJDREUxMjM0NQ%3D%3D ### Deploy to IoT Edge If required, add credentials to access your container registry to the IoT Edge device by adding them to IoT Hub &rarr; IoT Edge &rarr; Your Device &rarr; Set Modules &rarr; Container Registry settings. ![Decoder Sample - Edge Module Container Registry Permission](../../images/decodersample-edgepermission.png) Configure your IoT Edge gateway device to include the custom container. IoT Hub &rarr; IoT Edge &rarr; Your Device &rarr; Set Modules &rarr; Deployment Modules &rarr; Add &rarr; IoT Edge Module. Set the module Name and Image URI, pointing to your image created above. **Make sure to choose all lowercase letters for the Module Name as the container will be unreachable otherwise!** ![Decoder Sample - Edge Module](../../images/decodersample-edgemodule.png) To activate the decoder for a LoRa device, navigate to your IoT Hub &rarr; IoT Devices &rarr; Device Details &rarr; Device Twin and set the ```SensorDecoder``` value in the desired properties to: http://universaldecoder:8080/api/ A list of all available decoders can be retrieved by calling the endpoint: http://universaldecoder:8080/decoders ``` Again make sure to choose all lowercase letters for the module name to make sure it is reachable. In case the custom decoder is unreachable, throws an error or return invalid JSON, the error message will be shown in your device's messages in IoT Hub.","title":"Universal Decoder"},{"location":"samples/decoders/universal/#universal-decoder","text":"This project gives access to decoders in the TTN repo through a HTTP REST interface compliant with the LoraWan implementation in this repository. Codecs provided by TTN are stored in a well defined folder structure . The universal decoder copies the codec files into its docker image at build time for later use from the web application. As currently codecs are not implemented as node modules (see open issue ), these files were patched accordingly after being copied so that they can be imported and reused.","title":"Universal Decoder"},{"location":"samples/decoders/universal/#quick-start","text":"Install node dependencies and copy/patch codecs from the TTN repository: npm install npm run codecs Create docker image (replace amd64 with the architecture of your choice) docker build . -f Dockerfile.amd64 -t universaldecoder Run docker image: docker run --rm -d -p 8080 :8080 universaldecoder Call the built-in DecoderValueSensor decoder at the following url. You should see the result as JSON string. http://localhost:8080/api/DecoderValueSensor?devEui=0000000000000000&fport=1&payload=QUJDREUxMjM0NQ%3D%3D Finally list all available decoders with the following url: http://localhost:8080/decoders You can finally call any other supported decoder at: http://localhost:8080/api/<decoder>?devEui=0000000000000000&fport=<fport>&payload=<payload>","title":"Quick start"},{"location":"samples/decoders/universal/#local-development","text":"","title":"Local development"},{"location":"samples/decoders/universal/#start-local-server","text":"npm start You can access the universal decoder at the url available in the output of the previous command.","title":"Start local server"},{"location":"samples/decoders/universal/#run-tests","text":"npm test","title":"Run tests"},{"location":"samples/decoders/universal/#universal-decoder-rest-api","text":"The url accepted by the universal decoder follows the pattern: /api/<decoder>?devEui=<devEui>&fport=<fport>&payload=<payload>","title":"Universal Decoder REST API"},{"location":"samples/decoders/universal/#decoder","text":"This path parameter identifies the TTN decoder that will be used. You can get a list of all available decoders by calling the /decoders endpoint.","title":"decoder"},{"location":"samples/decoders/universal/#deveui","text":"LoRaWan unique end-device identifier.","title":"devEui"},{"location":"samples/decoders/universal/#fport","text":"LoRaWan Port field as integer value.","title":"fport"},{"location":"samples/decoders/universal/#payload","text":"Base64 and URL encoded payload to decode. For example, to test a payload of ABCDE12345 , you: Convert it to a base64 encoded string: QUJDREUxMjM0NQ== Convert the result to a valid URL parameter: QUJDREUxMjM0NQ%3D%3D Add this to your URL as the payload query parameter.","title":"payload"},{"location":"samples/decoders/universal/#deploying-to-azure-iot-edge","text":"","title":"Deploying to Azure IoT Edge"},{"location":"samples/decoders/universal/#push-docker-image-to-registry","text":"Create a docker image from your finished solution based on the target architecture and host it in an Azure Container Registry , on DockerHub or in any other container registry of your choice. Install the Azure IoT Edge for Visual Studio Code extension to build and push the Docker image. Make sure you are logged in to the Azure Container Registry you are using. Run docker login <mycontainerregistry>.azurecr.io on your development machine, or az acr login -n mycontainerregistry if the Azure CLI is available. Edit the file module.json to contain your container registry address, image name and version number: We provide the Dockerfiles for the following architectures: Dockerfile.amd64 Dockerfile.arm32v7 Dockerfile.arm64v8 To build the Docker image, right-click on the module.json file and select \"Build IoT Edge Module Image\" or \"Build and Push IoT Edge Module Image\". Select the architecture you want to build for from the drop-down menu. To temporarily test the container running you decoder using a webbrowser or Postman, you can manually start it in Docker and bind the container's port 8080 to a free port on your host machine (8080 is usually good). docker run --rm -it -p 8080 :8080 --name universaldecoder <container registry>/<image>:<tag> ```` Call the built-in ` DecoderValueSensor ` decoder at the following url: http://localhost:8080/api/DecoderValueSensor?devEui=0000000000000000&fport=1&payload=QUJDREUxMjM0NQ%3D%3D ### Deploy to IoT Edge If required, add credentials to access your container registry to the IoT Edge device by adding them to IoT Hub &rarr; IoT Edge &rarr; Your Device &rarr; Set Modules &rarr; Container Registry settings. ![Decoder Sample - Edge Module Container Registry Permission](../../images/decodersample-edgepermission.png) Configure your IoT Edge gateway device to include the custom container. IoT Hub &rarr; IoT Edge &rarr; Your Device &rarr; Set Modules &rarr; Deployment Modules &rarr; Add &rarr; IoT Edge Module. Set the module Name and Image URI, pointing to your image created above. **Make sure to choose all lowercase letters for the Module Name as the container will be unreachable otherwise!** ![Decoder Sample - Edge Module](../../images/decodersample-edgemodule.png) To activate the decoder for a LoRa device, navigate to your IoT Hub &rarr; IoT Devices &rarr; Device Details &rarr; Device Twin and set the ```SensorDecoder``` value in the desired properties to: http://universaldecoder:8080/api/ A list of all available decoders can be retrieved by calling the endpoint: http://universaldecoder:8080/decoders ``` Again make sure to choose all lowercase letters for the module name to make sure it is reachable. In case the custom decoder is unreachable, throws an error or return invalid JSON, the error message will be shown in your device's messages in IoT Hub.","title":"Push docker image to registry"},{"location":"testing/e2e_tests/","text":"E2E Tests This guide helps you to execute and author E2E tests on your local environment. Requirements +----------+ | | Dev | A | Machine | +------------+ | | | IoT Edge | +----------+ ) | LBS/PktFwd | | ) ) | NtwSrv | | (usb) | ) ) ) +------------+ | A ) ) +---------+ ) | Arduino | +---------+ LoRaWan solution up and running (IoT Edge Device, IoT Hub, LoRa Keys Azure Function, Redis, container registry etc.) Seeeduino LoRaWan device (leaf test device) connected via USB to a computer where the LoRaWan.Tests.E2E will run. Module LoRaWanNetworkSrvModule logging configured with following environment variables: LOG_LEVEL: 1 LOG_TO_TCP: true LOG_TO_TCP_ADDRESS: development machine IP address (ensure IoT Edge machine can ping it) E2E test configuration (in file appsettings.local.json ) has TCP logging enabled \"TcpLog\": \"true\" Setup LoRa Basics Station and Network Server setup Configure LoRa Basics Station and Network Server to run on your concentrator: Copy LoRaEngine/example.env file and name it .env . Update Container Registry settings and facade function app section with details of your created registry and function app. Update LoRaWanNetworkSrvModule settings: NET_SRV_LOG_LEVEL = 1 NET_SRV_LOGTO_HUB = true NET_SRV_LOG_TO_TCP = true NET_SRV_LOG_TO_TCP_ADDRESS = <your-local-ip-address> Update LBS_TC_URI : LBS_TC_URI=ws://172.17.0.1:5000 Build and push IoT Edge solution to your container registry using LoRaEngine/deployment.lbs.template.json file. In VS Code: Ctrl+Shift+P -> Azure IoT Edge: Bild and Push IoT Edge Solution -> select template file. Create deployment for a single device using generated deployment template. In VS Code, right-click on LoRaEngine/config/deployment.lbs.json and select Create Deployment for Single Device. Provision a device in your IoT Hub by following the Basics Station configuration docs. End device setup Connect and setup Seeduino Arduino with the serial pass sketch void setup () { Serial1 . begin ( 9600 ); SerialUSB . begin ( 115200 ); } void loop () { while ( Serial1 . available ()) { SerialUSB . write ( Serial1 . read ()); } while ( SerialUSB . available ()) { Serial1 . write ( SerialUSB . read ()); } } E2E test configuration Create/edit E2E settings in file appsettings.local.json The value of LeafDeviceSerialPort in Windows will be the COM port where the Arduino board is connected to (Arduino IDE displays it). On macos you can discover through ls /dev/tty* and/or ls /dev/cu* bash commands. On Linux you can discover them with ls /dev/ttyACM* . { \"testConfiguration\" : { \"IoTHubEventHubConnectionString\" : \"Endpoint=sb://xxxx.servicebus.windows.net/;SharedAccessKeyName=iothubowner;SharedAccessKey=xxx;EntityPath=xxxxx\" , \"IoTHubEventHubConsumerGroup\" : \"your-iothub-consumer-group\" , \"IoTHubConnectionString\" : \"HostName=xxxx.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=xxx\" , \"EnsureHasEventDelayBetweenReadsInSeconds\" : \"15\" , \"EnsureHasEventMaximumTries\" : \"5\" , \"LeafDeviceSerialPort\" : \"your-usb-port\" , \"LeafDeviceGatewayID\" : \"your-iot-edge-device-id\" , \"CreateDevices\" : true , \"NetworkServerModuleLogAssertLevel\" : \"Error\" , \"DevicePrefix\" : \"your-two-letter-device-prefix\" , \"TcpLog\" : \"true\" , \"FunctionAppBaseUrl\" : \"https://your-function-app.azurewebsites.net/api/\" , \"FunctionAppCode\" : \"your-function-code=\" } } If the value of CreateDevices setting is true, running the tests will create/update devices in IoT Hub prior to executing tests. Devices will be created starting with ID \"0000000000000001\". The deviceID prefix can be modified by setting a value in DevicePrefix setting ('FF' \u2192 'FF00000000000001'). Creating a new test Each test uses an unique device to ensure transmissions don't exceed LoRaWan regulations. Additionally, it makes it easier to track logs for each test. To create a new device modify the IntegrationTestFixture class by: Creating a new property of type TestDeviceInfo as (increment the device ids by 1): // Device13_OTAA: used for wrong AppEUI OTAA join public TestDeviceInfo Device13_OTAA { get ; private set ; } Create the TestDeviceInfo instance in IntegrationTestFixture.SetupDevices() method // Device13_OTAA: used for Join with wrong AppEUI Device13_OTAA = new TestDeviceInfo () { DeviceID = \"0000000000000013\" , AppEUI = \"BE7A00000000FEE3\" , AppKey = \"8AFE71A145B253E49C3031AD068277A3\" , SensorDecoder = \"DecoderValueSensor\" , // GatewayID property of the device GatewayID = gatewayID , // Indicates if the device exists in IoT Hub // Some tests don't require a device to actually exist IsIoTHubDevice = true , }; Create the test method / fact in a test class. If a new test class is needed (to group logically test) read the section 'Creating Test Class'). Code should be similar to this: // Tests using a invalid Network Session key, resulting in mic failed // Uses Device8_ABP [Fact] public async Task Test_ABP_Invalid_NwkSKey_Fails_With_Mic_Error () { var device = TestFixture . Device8_ABP ; LogTestStart ( device ); var nwkSKeyToUse = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" ; Assert . NotEqual ( nwkSKeyToUse , device . NwkSKey ); await ArduinoDevice . setDeviceModeAsync ( LoRaArduinoSerial . _device_mode_t . LWABP ); await ArduinoDevice . setIdAsync ( device . DevAddr , device . DeviceID , null ); await ArduinoDevice . setKeyAsync ( nwkSKeyToUse , device . AppSKey , null ); await ArduinoDevice . SetupLora ( TestFixture . Configuration . LoraRegion ); await ArduinoDevice . transferPacketAsync ( \"100\" , 10 ); // THIS DELAY IS IMPORTANT! // Don't pollute radio transmission channel await Task . Delay ( Constants . DELAY_FOR_SERIAL_AFTER_SENDING_PACKET ); // Add here test logic } Creating Test Class E2E tests cannot be parallelized because they all share dependency to Arduino device. Those classes also rely on TCP and IoT Event Hub listeners that should be created once per test execution, not per test. Therefore, when creating a new test class follow the guidelines: Use attribute [Collection(Constants.TestCollectionName)] to ensure executing in serial inherit from IntegrationTestBase . Create a single constructor receiving a IntegrationTestFixture as parameter. Call the base class constructor passing the parameter. Example: // Tests xxxx [Collection(Constants.TestCollectionName)] // Set the same collection to ensure execution in serial public sealed class MyTest : IntegrationTestBase { // Constructor receives the IntegrationTestFixture that is a singleton public MyTest ( IntegrationTestFixture testFixture ) : base ( testFixture ) { } } Asserting Assertions and expectations are implemented in 3 levels. Arduino Serial logs Serial logs from Arduino allow test cases to ensure the leaf device is receiving the correct response from the antena (LoRaPktFwd module). Checks can be done the following way: // After transferPacketWithConfirmed: Expectation from serial \"+CMSG: ACK Received\" // It has retries to account for i/o delays await AssertUtils . ContainsWithRetriesAsync ( \"+CMSG: ACK Received\" , ArduinoDevice . SerialLogs ); LoRaWan Network Server Module logs The network server module logs important execution steps. Those messages can be used to ensure expected actions happened in the network server module. This validation creates a tight dependency between tests and logging. We might need to reavaluate it if the friction between code changes and breaking tests gets too high. An option is to have the Network server publish events when an operation happens and have the test create assertion on them (i.e. { \"type\": \"otaajoin\", \"status\": \"succeeded\", \"deviceid\": \"xxx\", \"time\": \"a-date\" } ). Module logs can be listened from IoT Hub or TCP (experimental). Validating against the module logs. // Ensures that the message 0000000000000004: message '{\"value\": 51}' sent to hub is logged // It contains retries to account for i/o delays await TestFixture . AssertNetworkServerModuleLogStartsWithAsync ( $\"{device.DeviceID}: message '{{\\\"value\\\":{msg}}}' sent to hub\" ); IoT Hub Device Message For end to end validation we listen for device messages arriving in IoT Hub. Examples: // Ensure device payload is available. It contains retries to account for i/o delays // Data: {\"value\": 51} var expectedPayload = $\"{{\\\"value\\\":{msg}}}\" ; await TestFixture . AssertIoTHubDeviceMessageExistsAsync ( device . DeviceID , expectedPayload );","title":"E2E Tests"},{"location":"testing/e2e_tests/#e2e-tests","text":"This guide helps you to execute and author E2E tests on your local environment.","title":"E2E Tests"},{"location":"testing/e2e_tests/#requirements","text":"+----------+ | | Dev | A | Machine | +------------+ | | | IoT Edge | +----------+ ) | LBS/PktFwd | | ) ) | NtwSrv | | (usb) | ) ) ) +------------+ | A ) ) +---------+ ) | Arduino | +---------+ LoRaWan solution up and running (IoT Edge Device, IoT Hub, LoRa Keys Azure Function, Redis, container registry etc.) Seeeduino LoRaWan device (leaf test device) connected via USB to a computer where the LoRaWan.Tests.E2E will run. Module LoRaWanNetworkSrvModule logging configured with following environment variables: LOG_LEVEL: 1 LOG_TO_TCP: true LOG_TO_TCP_ADDRESS: development machine IP address (ensure IoT Edge machine can ping it) E2E test configuration (in file appsettings.local.json ) has TCP logging enabled \"TcpLog\": \"true\"","title":"Requirements"},{"location":"testing/e2e_tests/#setup","text":"","title":"Setup"},{"location":"testing/e2e_tests/#lora-basics-station-and-network-server-setup","text":"Configure LoRa Basics Station and Network Server to run on your concentrator: Copy LoRaEngine/example.env file and name it .env . Update Container Registry settings and facade function app section with details of your created registry and function app. Update LoRaWanNetworkSrvModule settings: NET_SRV_LOG_LEVEL = 1 NET_SRV_LOGTO_HUB = true NET_SRV_LOG_TO_TCP = true NET_SRV_LOG_TO_TCP_ADDRESS = <your-local-ip-address> Update LBS_TC_URI : LBS_TC_URI=ws://172.17.0.1:5000 Build and push IoT Edge solution to your container registry using LoRaEngine/deployment.lbs.template.json file. In VS Code: Ctrl+Shift+P -> Azure IoT Edge: Bild and Push IoT Edge Solution -> select template file. Create deployment for a single device using generated deployment template. In VS Code, right-click on LoRaEngine/config/deployment.lbs.json and select Create Deployment for Single Device. Provision a device in your IoT Hub by following the Basics Station configuration docs.","title":"LoRa Basics Station and Network Server setup"},{"location":"testing/e2e_tests/#end-device-setup","text":"Connect and setup Seeduino Arduino with the serial pass sketch void setup () { Serial1 . begin ( 9600 ); SerialUSB . begin ( 115200 ); } void loop () { while ( Serial1 . available ()) { SerialUSB . write ( Serial1 . read ()); } while ( SerialUSB . available ()) { Serial1 . write ( SerialUSB . read ()); } }","title":"End device setup"},{"location":"testing/e2e_tests/#e2e-test-configuration","text":"Create/edit E2E settings in file appsettings.local.json The value of LeafDeviceSerialPort in Windows will be the COM port where the Arduino board is connected to (Arduino IDE displays it). On macos you can discover through ls /dev/tty* and/or ls /dev/cu* bash commands. On Linux you can discover them with ls /dev/ttyACM* . { \"testConfiguration\" : { \"IoTHubEventHubConnectionString\" : \"Endpoint=sb://xxxx.servicebus.windows.net/;SharedAccessKeyName=iothubowner;SharedAccessKey=xxx;EntityPath=xxxxx\" , \"IoTHubEventHubConsumerGroup\" : \"your-iothub-consumer-group\" , \"IoTHubConnectionString\" : \"HostName=xxxx.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=xxx\" , \"EnsureHasEventDelayBetweenReadsInSeconds\" : \"15\" , \"EnsureHasEventMaximumTries\" : \"5\" , \"LeafDeviceSerialPort\" : \"your-usb-port\" , \"LeafDeviceGatewayID\" : \"your-iot-edge-device-id\" , \"CreateDevices\" : true , \"NetworkServerModuleLogAssertLevel\" : \"Error\" , \"DevicePrefix\" : \"your-two-letter-device-prefix\" , \"TcpLog\" : \"true\" , \"FunctionAppBaseUrl\" : \"https://your-function-app.azurewebsites.net/api/\" , \"FunctionAppCode\" : \"your-function-code=\" } } If the value of CreateDevices setting is true, running the tests will create/update devices in IoT Hub prior to executing tests. Devices will be created starting with ID \"0000000000000001\". The deviceID prefix can be modified by setting a value in DevicePrefix setting ('FF' \u2192 'FF00000000000001').","title":"E2E test configuration"},{"location":"testing/e2e_tests/#creating-a-new-test","text":"Each test uses an unique device to ensure transmissions don't exceed LoRaWan regulations. Additionally, it makes it easier to track logs for each test. To create a new device modify the IntegrationTestFixture class by: Creating a new property of type TestDeviceInfo as (increment the device ids by 1): // Device13_OTAA: used for wrong AppEUI OTAA join public TestDeviceInfo Device13_OTAA { get ; private set ; } Create the TestDeviceInfo instance in IntegrationTestFixture.SetupDevices() method // Device13_OTAA: used for Join with wrong AppEUI Device13_OTAA = new TestDeviceInfo () { DeviceID = \"0000000000000013\" , AppEUI = \"BE7A00000000FEE3\" , AppKey = \"8AFE71A145B253E49C3031AD068277A3\" , SensorDecoder = \"DecoderValueSensor\" , // GatewayID property of the device GatewayID = gatewayID , // Indicates if the device exists in IoT Hub // Some tests don't require a device to actually exist IsIoTHubDevice = true , }; Create the test method / fact in a test class. If a new test class is needed (to group logically test) read the section 'Creating Test Class'). Code should be similar to this: // Tests using a invalid Network Session key, resulting in mic failed // Uses Device8_ABP [Fact] public async Task Test_ABP_Invalid_NwkSKey_Fails_With_Mic_Error () { var device = TestFixture . Device8_ABP ; LogTestStart ( device ); var nwkSKeyToUse = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" ; Assert . NotEqual ( nwkSKeyToUse , device . NwkSKey ); await ArduinoDevice . setDeviceModeAsync ( LoRaArduinoSerial . _device_mode_t . LWABP ); await ArduinoDevice . setIdAsync ( device . DevAddr , device . DeviceID , null ); await ArduinoDevice . setKeyAsync ( nwkSKeyToUse , device . AppSKey , null ); await ArduinoDevice . SetupLora ( TestFixture . Configuration . LoraRegion ); await ArduinoDevice . transferPacketAsync ( \"100\" , 10 ); // THIS DELAY IS IMPORTANT! // Don't pollute radio transmission channel await Task . Delay ( Constants . DELAY_FOR_SERIAL_AFTER_SENDING_PACKET ); // Add here test logic }","title":"Creating a new test"},{"location":"testing/e2e_tests/#creating-test-class","text":"E2E tests cannot be parallelized because they all share dependency to Arduino device. Those classes also rely on TCP and IoT Event Hub listeners that should be created once per test execution, not per test. Therefore, when creating a new test class follow the guidelines: Use attribute [Collection(Constants.TestCollectionName)] to ensure executing in serial inherit from IntegrationTestBase . Create a single constructor receiving a IntegrationTestFixture as parameter. Call the base class constructor passing the parameter. Example: // Tests xxxx [Collection(Constants.TestCollectionName)] // Set the same collection to ensure execution in serial public sealed class MyTest : IntegrationTestBase { // Constructor receives the IntegrationTestFixture that is a singleton public MyTest ( IntegrationTestFixture testFixture ) : base ( testFixture ) { } }","title":"Creating Test Class"},{"location":"testing/e2e_tests/#asserting","text":"Assertions and expectations are implemented in 3 levels.","title":"Asserting"},{"location":"testing/e2e_tests/#arduino-serial-logs","text":"Serial logs from Arduino allow test cases to ensure the leaf device is receiving the correct response from the antena (LoRaPktFwd module). Checks can be done the following way: // After transferPacketWithConfirmed: Expectation from serial \"+CMSG: ACK Received\" // It has retries to account for i/o delays await AssertUtils . ContainsWithRetriesAsync ( \"+CMSG: ACK Received\" , ArduinoDevice . SerialLogs );","title":"Arduino Serial logs"},{"location":"testing/e2e_tests/#lorawan-network-server-module-logs","text":"The network server module logs important execution steps. Those messages can be used to ensure expected actions happened in the network server module. This validation creates a tight dependency between tests and logging. We might need to reavaluate it if the friction between code changes and breaking tests gets too high. An option is to have the Network server publish events when an operation happens and have the test create assertion on them (i.e. { \"type\": \"otaajoin\", \"status\": \"succeeded\", \"deviceid\": \"xxx\", \"time\": \"a-date\" } ). Module logs can be listened from IoT Hub or TCP (experimental). Validating against the module logs. // Ensures that the message 0000000000000004: message '{\"value\": 51}' sent to hub is logged // It contains retries to account for i/o delays await TestFixture . AssertNetworkServerModuleLogStartsWithAsync ( $\"{device.DeviceID}: message '{{\\\"value\\\":{msg}}}' sent to hub\" );","title":"LoRaWan Network Server Module logs"},{"location":"testing/e2e_tests/#iot-hub-device-message","text":"For end to end validation we listen for device messages arriving in IoT Hub. Examples: // Ensure device payload is available. It contains retries to account for i/o delays // Data: {\"value\": 51} var expectedPayload = $\"{{\\\"value\\\":{msg}}}\" ; await TestFixture . AssertIoTHubDeviceMessageExistsAsync ( device . DeviceID , expectedPayload );","title":"IoT Hub Device Message"},{"location":"testing/integration_tests/","text":"Integration Tests Coming soon","title":"Integration Tests"},{"location":"testing/integration_tests/#integration-tests","text":"Coming soon","title":"Integration Tests"},{"location":"tools/device-provisioning/","text":"LoRa device provisioning CLI This is a Command Line Interface Provisioning Tool to list, query, verify add, update, and remove LoRaWAN leaf devices configured in Azure IoT Hub for the Azure IoT Edge LoRaWAN Gateway project located at: http://aka.ms/lora Building You can create an platform specific executable by running dotnet publish -c Release -r win10-x64 dotnet publish -c Release -r linux-x64 dotnet publish -c Release -r osx-x64 See the .NET Core RID Catalog for a list of valid runtime identifiers. Running You can run the tool from the command line using .NET Core by executing the dotnet run command from the project folder dotnet run -- ( add verbs and parameters here ) or dotnet loradeviceprovisioning.dll from the bin folder. dotnet .\\ bin \\ Release \\ netcoreapp3 . 1 \\ loradeviceprovisioning . dll -- ( add verbs and parameters here ) Setting up appsettings.json needs to be in the same directory as the cli-lora-device-provisioning binary (verifyloradevice.dll or verifyloradevice.exe). appsettings.json needs to contain a connection string from the Azure IoT Hub you want to work with. This connection string needs to belong to a shared access policy with registry read , registry write and service connect permissions enabled. You can use the default policy named iothubowner . { \"IoTHubConnectionString\" : \"HostName=youriothub.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=AeVMLayazGTS9QRMJtFGSSNwdhUdYR5VwCjaafc3DL0=\" } appsettings.json may optionally contain a Network Id (NetId) in case your solution does not use the default Network Id 000001. Since just the last byte from this 3 hex string byte array (6 characters) are used to create a valid DevAddr for ABP LoRa devices, the setting can be either the full 3 bytes (000000 to FFFFFF) or just the shortened, last byte (0 to FF). { \"IoTHubConnectionString\" : \"HostName=youriothub.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=AeVMLayazGTS9QRMJtFGSSNwdhUdYR5VwCjaafc3DL0=\" , \"NetId\" : \"000001\" } If NetId is not set, the default 000001 is used. If you have a NetId set in appsettings.json, you can always override it by calling a command of this utility with the --netid option. To learn more about what each of the settings in the LoRa device twin does, refer to the Quick Start Guide . Supported commands The following verbs/commands are supported: verb description list Lits devices in IoT Hub. query Query a device twin. verify Verify a single device in IoT Hub. bulkverify Bulk verify all devices in IoT Hub. add Add a new device to IoT Hub. update Update an existing device in IoT Hub. remove Remove an existing device from IoT Hub. help Display more information on a specific command. version Display version information. list List the devices in IoT Hub and show their device twin. Example: dotnet run -- list The list verb supports the following parameters: parameter required description --page no Devices per page. Default is 10. --total no Maximum number of devices to list. Default is all. --help no Display this help screen. --version no Display version information. query Show the device twin for an existing device in IoT Hub by it's DevEUI / Device Id. Example: dotnet run -- query - -deveui 33CCC86800430010 The query verb supports the following parameters: parameter required description --deveui yes DevEUI / Device Id. --help no Display this help screen. --version no Display version information. verify Verify an existing device in IoT Hub by it's DevEUI / Device Id. Example: dotnet run -- verify - -deveui 33CCC86800430010 The verify verb supports the following parameters: parameter required description --deveui yes DevEUI / Device Id. --netid no Network ID (Only for ABP devices): A 3 bit hex string. Will default to 000001 or NetId set in settings file if left blank. --help no Display this help screen. --version no Display version information. bulkverify Bulk verify all devices in IoT Hub. Only shows the devices that have configuration errors and displays a summary in the end how many devcies are properly configured and how many contain errors. Example: dotnet run -- bulkverify - -page 10 The bulkverify verb supports the following parameters: parameter required description --page no Errors per page. Default is all. --help no Display this help screen. --version no Display version information. add Add a new device to IoT Hub. The data entered will be verified and only created in IoT Hub if it's valid. All required fields that are not provided will be automatically populated with valid, randomly generated by the tool. The only mandatory field is type which has to be set to either ABP or OTAA . To learn more about what each of the settings in the LoRa device twin does, refer to the Quick Start Guide . Example: dotnet run -- add - -type abp - -deveui 33CCC86800430010 - -decoder http :// decodermodule / api / customdecoder The add verb supports the following parameters: parameter required description --type yes Device type: Must be ABP or OTAA. --deveui no DevEUI / Device Id: A 16 bit hex string. Will be randomly generated if left blank. --appskey no AppSKey (Only for ABP devices): A 16 bit hex string. Will be randomly generated if left blank. --nwkskey no NwkSKey (Only for ABP devices): A 16 bit hex string. Will be randomly generated if left blank. --devaddr no DevAddr (Only for ABP devices): A 4 bit hex string. Will be randomly generated if left blank. --netid no Network ID (Only for ABP devices): A 3 bit hex string. Will default to 000001 or NetId set in settings file if left blank. --abprelaxmode no ABPRelaxMode (ABP relaxed framecounter, only for ABP devices): True or false. --appeui no AppEUI (only for OTAA devices): A 16 bit hex string. Will be randomly generated if left blank. --appkey no AppKey (only for OTAA devices): A 16 bit hex string. Will be randomly generated if left blank. --gatewayid no GatewayID: A hostname. --decoder no SensorDecoder: The name of an integrated decoder function or the URI to a decoder in a custom decoder module in the format: http://modulename/api/decodername. --classtype no ClassType: \"A\" (default) or \"C\". --downlinkenabled no DownlinkEnabled: True or false. --preferredwindow no PreferredWindow (Preferred receive window): 1 or 2. --deduplication no Deduplication: None (default), Drop or Mark. --rx2datarate no Rx2DataRate (Receive window 2 data rate, currently only supported for OTAA devices): Any of the allowed data rates. EU: SF12BW125, SF11BW125, SF10BW125, SF8BW125, SF7BW125, SF7BW250 or 50. US: SF10BW125, SF9BW125, SF8BW125, SF7BW125, SF8BW500, SF12BW500, SF11BW500, SF10BW500, SF9BW500, SF8BW500, SF8BW500. --rx1droffset no Rx1DrOffset (Receive window 1 data rate offset, currently only supported for OTAA devices): 0 through 15. --rxdelay no RxDelay (Delay in seconds for sending downstream messages, currently only supported for OTAA devices): 0 through 15. --keepalivetimeout no KeepAliveTimeout (KeepAliveTimeout (Timeout in seconds before device client connection is closed): 0 or 60 and above. --supports32bitfcnt no Supports32BitFCnt (Support for 32bit frame counter): True or false. --fcntupstart no FCntUpStart (Frame counter up start value): 0 through 4294967295. --fcntdownstart no FCntDownStart (Frame counter down start value): 0 through 4294967295. --fcntresetcounter no FCntResetCounter (Frame counter reset counter value): 0 through 4294967295. --help no Display this help screen. --version no Display version information. update Update the twin information for an existing device. To remove an existing value that is currently set on the twin, pass it the value null . To learn more about what each of the settings in the LoRa device twin does, refer to the Quick Start Guide . Example: dotnet run -- update - -deveui 33CCC86800430010 - -decoder null The update verb supports the following parameters: parameter required description --deveui yes DevEUI / Device Id: A 16 bit hex string. --appskey no AppSKey (Only for ABP devices): A 16 bit hex string. --nwkskey no NwkSKey (Only for ABP devices): A 16 bit hex string. --devaddr no DevAddr (Only for ABP devices): A 4 bit hex string. --netid no Network ID (Only for ABP devices): A 3 bit hex string. Will default to 000001 or NetId set in settings file if left blank. --abprelaxmode no ABPRelaxMode (ABP relaxed framecounter, only for ABP devices): True or false. --appeui no AppEUI (only for OTAA devices): A 16 bit hex string. --appkey no AppKey (only for OTAA devices): A 16 bit hex string. --gatewayid no GatewayID: A hostname. --decoder no SensorDecoder: The name of an integrated decoder function or the URI to a decoder in a custom decoder module in the format: http://modulename/api/decodername . --classtype no ClassType: \"A\" (default) or \"C\". --downlinkenabled no DownlinkEnabled: True or false. --preferredwindow no PreferredWindow (Preferred receive window): 1 or 2. --deduplication no Deduplication: None (default), Drop or Mark. --rx2datarate no Rx2DataRate (Receive window 2 data rate, currently only supported for OTAA devices): Any of the allowed data rates. EU: SF12BW125, SF11BW125, SF10BW125, SF8BW125, SF7BW125, SF7BW250 or 50. US: SF10BW125, SF9BW125, SF8BW125, SF7BW125, SF8BW500, SF12BW500, SF11BW500, SF10BW500, SF9BW500, SF8BW500, SF8BW500. --rx1droffset no Rx1DrOffset (Receive window 1 data rate offset, currently only supported for OTAA devices): 0 through 15. --rxdelay no RxDelay (Delay in seconds for sending downstream messages, currently only supported for OTAA devices): 0 through 15. --keepalivetimeout no KeepAliveTimeout (KeepAliveTimeout (Timeout in seconds before device client connection is closed): 0 or 60 and above. --supports32bitfcnt no Supports32BitFCnt (Support for 32bit frame counter): True or false. --fcntupstart no FCntUpStart (Frame counter up start value): 0 through 4294967295. --fcntdownstart no FCntDownStart (Frame counter down start value): 0 through 4294967295. --fcntresetcounter no FCntResetCounter (Frame counter reset counter value): 0 through 4294967295. --help no Display this help screen. --version no Display version information. remove Remove an existing device from IoT Hub by it's DevEUI / Device Id. Example: dotnet run -- remove - -deveui 33CCC86800430010 The query verb supports the following parameters: parameter required description --deveui yes DevEUI / Device Id. --help no Display this help screen. --version no Display version information.","title":"LoRa device provisioning CLI"},{"location":"tools/device-provisioning/#lora-device-provisioning-cli","text":"This is a Command Line Interface Provisioning Tool to list, query, verify add, update, and remove LoRaWAN leaf devices configured in Azure IoT Hub for the Azure IoT Edge LoRaWAN Gateway project located at: http://aka.ms/lora","title":"LoRa device provisioning CLI"},{"location":"tools/device-provisioning/#building","text":"You can create an platform specific executable by running dotnet publish -c Release -r win10-x64 dotnet publish -c Release -r linux-x64 dotnet publish -c Release -r osx-x64 See the .NET Core RID Catalog for a list of valid runtime identifiers.","title":"Building"},{"location":"tools/device-provisioning/#running","text":"You can run the tool from the command line using .NET Core by executing the dotnet run command from the project folder dotnet run -- ( add verbs and parameters here ) or dotnet loradeviceprovisioning.dll from the bin folder. dotnet .\\ bin \\ Release \\ netcoreapp3 . 1 \\ loradeviceprovisioning . dll -- ( add verbs and parameters here )","title":"Running"},{"location":"tools/device-provisioning/#setting-up","text":"appsettings.json needs to be in the same directory as the cli-lora-device-provisioning binary (verifyloradevice.dll or verifyloradevice.exe). appsettings.json needs to contain a connection string from the Azure IoT Hub you want to work with. This connection string needs to belong to a shared access policy with registry read , registry write and service connect permissions enabled. You can use the default policy named iothubowner . { \"IoTHubConnectionString\" : \"HostName=youriothub.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=AeVMLayazGTS9QRMJtFGSSNwdhUdYR5VwCjaafc3DL0=\" } appsettings.json may optionally contain a Network Id (NetId) in case your solution does not use the default Network Id 000001. Since just the last byte from this 3 hex string byte array (6 characters) are used to create a valid DevAddr for ABP LoRa devices, the setting can be either the full 3 bytes (000000 to FFFFFF) or just the shortened, last byte (0 to FF). { \"IoTHubConnectionString\" : \"HostName=youriothub.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=AeVMLayazGTS9QRMJtFGSSNwdhUdYR5VwCjaafc3DL0=\" , \"NetId\" : \"000001\" } If NetId is not set, the default 000001 is used. If you have a NetId set in appsettings.json, you can always override it by calling a command of this utility with the --netid option. To learn more about what each of the settings in the LoRa device twin does, refer to the Quick Start Guide .","title":"Setting up"},{"location":"tools/device-provisioning/#supported-commands","text":"The following verbs/commands are supported: verb description list Lits devices in IoT Hub. query Query a device twin. verify Verify a single device in IoT Hub. bulkverify Bulk verify all devices in IoT Hub. add Add a new device to IoT Hub. update Update an existing device in IoT Hub. remove Remove an existing device from IoT Hub. help Display more information on a specific command. version Display version information.","title":"Supported commands"},{"location":"tools/device-provisioning/#list","text":"List the devices in IoT Hub and show their device twin. Example: dotnet run -- list The list verb supports the following parameters: parameter required description --page no Devices per page. Default is 10. --total no Maximum number of devices to list. Default is all. --help no Display this help screen. --version no Display version information.","title":"list"},{"location":"tools/device-provisioning/#query","text":"Show the device twin for an existing device in IoT Hub by it's DevEUI / Device Id. Example: dotnet run -- query - -deveui 33CCC86800430010 The query verb supports the following parameters: parameter required description --deveui yes DevEUI / Device Id. --help no Display this help screen. --version no Display version information.","title":"query"},{"location":"tools/device-provisioning/#verify","text":"Verify an existing device in IoT Hub by it's DevEUI / Device Id. Example: dotnet run -- verify - -deveui 33CCC86800430010 The verify verb supports the following parameters: parameter required description --deveui yes DevEUI / Device Id. --netid no Network ID (Only for ABP devices): A 3 bit hex string. Will default to 000001 or NetId set in settings file if left blank. --help no Display this help screen. --version no Display version information.","title":"verify"},{"location":"tools/device-provisioning/#bulkverify","text":"Bulk verify all devices in IoT Hub. Only shows the devices that have configuration errors and displays a summary in the end how many devcies are properly configured and how many contain errors. Example: dotnet run -- bulkverify - -page 10 The bulkverify verb supports the following parameters: parameter required description --page no Errors per page. Default is all. --help no Display this help screen. --version no Display version information.","title":"bulkverify"},{"location":"tools/device-provisioning/#add","text":"Add a new device to IoT Hub. The data entered will be verified and only created in IoT Hub if it's valid. All required fields that are not provided will be automatically populated with valid, randomly generated by the tool. The only mandatory field is type which has to be set to either ABP or OTAA . To learn more about what each of the settings in the LoRa device twin does, refer to the Quick Start Guide . Example: dotnet run -- add - -type abp - -deveui 33CCC86800430010 - -decoder http :// decodermodule / api / customdecoder The add verb supports the following parameters: parameter required description --type yes Device type: Must be ABP or OTAA. --deveui no DevEUI / Device Id: A 16 bit hex string. Will be randomly generated if left blank. --appskey no AppSKey (Only for ABP devices): A 16 bit hex string. Will be randomly generated if left blank. --nwkskey no NwkSKey (Only for ABP devices): A 16 bit hex string. Will be randomly generated if left blank. --devaddr no DevAddr (Only for ABP devices): A 4 bit hex string. Will be randomly generated if left blank. --netid no Network ID (Only for ABP devices): A 3 bit hex string. Will default to 000001 or NetId set in settings file if left blank. --abprelaxmode no ABPRelaxMode (ABP relaxed framecounter, only for ABP devices): True or false. --appeui no AppEUI (only for OTAA devices): A 16 bit hex string. Will be randomly generated if left blank. --appkey no AppKey (only for OTAA devices): A 16 bit hex string. Will be randomly generated if left blank. --gatewayid no GatewayID: A hostname. --decoder no SensorDecoder: The name of an integrated decoder function or the URI to a decoder in a custom decoder module in the format: http://modulename/api/decodername. --classtype no ClassType: \"A\" (default) or \"C\". --downlinkenabled no DownlinkEnabled: True or false. --preferredwindow no PreferredWindow (Preferred receive window): 1 or 2. --deduplication no Deduplication: None (default), Drop or Mark. --rx2datarate no Rx2DataRate (Receive window 2 data rate, currently only supported for OTAA devices): Any of the allowed data rates. EU: SF12BW125, SF11BW125, SF10BW125, SF8BW125, SF7BW125, SF7BW250 or 50. US: SF10BW125, SF9BW125, SF8BW125, SF7BW125, SF8BW500, SF12BW500, SF11BW500, SF10BW500, SF9BW500, SF8BW500, SF8BW500. --rx1droffset no Rx1DrOffset (Receive window 1 data rate offset, currently only supported for OTAA devices): 0 through 15. --rxdelay no RxDelay (Delay in seconds for sending downstream messages, currently only supported for OTAA devices): 0 through 15. --keepalivetimeout no KeepAliveTimeout (KeepAliveTimeout (Timeout in seconds before device client connection is closed): 0 or 60 and above. --supports32bitfcnt no Supports32BitFCnt (Support for 32bit frame counter): True or false. --fcntupstart no FCntUpStart (Frame counter up start value): 0 through 4294967295. --fcntdownstart no FCntDownStart (Frame counter down start value): 0 through 4294967295. --fcntresetcounter no FCntResetCounter (Frame counter reset counter value): 0 through 4294967295. --help no Display this help screen. --version no Display version information.","title":"add"},{"location":"tools/device-provisioning/#update","text":"Update the twin information for an existing device. To remove an existing value that is currently set on the twin, pass it the value null . To learn more about what each of the settings in the LoRa device twin does, refer to the Quick Start Guide . Example: dotnet run -- update - -deveui 33CCC86800430010 - -decoder null The update verb supports the following parameters: parameter required description --deveui yes DevEUI / Device Id: A 16 bit hex string. --appskey no AppSKey (Only for ABP devices): A 16 bit hex string. --nwkskey no NwkSKey (Only for ABP devices): A 16 bit hex string. --devaddr no DevAddr (Only for ABP devices): A 4 bit hex string. --netid no Network ID (Only for ABP devices): A 3 bit hex string. Will default to 000001 or NetId set in settings file if left blank. --abprelaxmode no ABPRelaxMode (ABP relaxed framecounter, only for ABP devices): True or false. --appeui no AppEUI (only for OTAA devices): A 16 bit hex string. --appkey no AppKey (only for OTAA devices): A 16 bit hex string. --gatewayid no GatewayID: A hostname. --decoder no SensorDecoder: The name of an integrated decoder function or the URI to a decoder in a custom decoder module in the format: http://modulename/api/decodername . --classtype no ClassType: \"A\" (default) or \"C\". --downlinkenabled no DownlinkEnabled: True or false. --preferredwindow no PreferredWindow (Preferred receive window): 1 or 2. --deduplication no Deduplication: None (default), Drop or Mark. --rx2datarate no Rx2DataRate (Receive window 2 data rate, currently only supported for OTAA devices): Any of the allowed data rates. EU: SF12BW125, SF11BW125, SF10BW125, SF8BW125, SF7BW125, SF7BW250 or 50. US: SF10BW125, SF9BW125, SF8BW125, SF7BW125, SF8BW500, SF12BW500, SF11BW500, SF10BW500, SF9BW500, SF8BW500, SF8BW500. --rx1droffset no Rx1DrOffset (Receive window 1 data rate offset, currently only supported for OTAA devices): 0 through 15. --rxdelay no RxDelay (Delay in seconds for sending downstream messages, currently only supported for OTAA devices): 0 through 15. --keepalivetimeout no KeepAliveTimeout (KeepAliveTimeout (Timeout in seconds before device client connection is closed): 0 or 60 and above. --supports32bitfcnt no Supports32BitFCnt (Support for 32bit frame counter): True or false. --fcntupstart no FCntUpStart (Frame counter up start value): 0 through 4294967295. --fcntdownstart no FCntDownStart (Frame counter down start value): 0 through 4294967295. --fcntresetcounter no FCntResetCounter (Frame counter reset counter value): 0 through 4294967295. --help no Display this help screen. --version no Display version information.","title":"update"},{"location":"tools/device-provisioning/#remove","text":"Remove an existing device from IoT Hub by it's DevEUI / Device Id. Example: dotnet run -- remove - -deveui 33CCC86800430010 The query verb supports the following parameters: parameter required description --deveui yes DevEUI / Device Id. --help no Display this help screen. --version no Display version information.","title":"remove"},{"location":"user-guide/architecture/","text":"Architecture and Concepts for the LoRaWAN starter kit Background LoRaWAN is a type of wireless wide-area networking that is designed to allow long-range communication at a low bit rate among low-power connected objects, such as sensors operated on a battery. Network topology is of star-of-stars type, with the leaf sensors sending data to gateways for forwarding telemetry to and receiving commands from backing Internet services. Nowadays, even for simple scenarios like having 10 devices connected to a single LoRaWan gateway (hardware with antenna), you need to connect your gateway to a Network Server and then work through connectors provided by the server vendor to integrate your LoRa gateways and devices with the back end. These setups can be connected to Azure IoT Hub quite easily. As a matter of fact such scenarios exist . Customers looking for an operated network with national or international reach (e.g. fleet operators, logistics) will tend to choose this setup accepting the potentially higher complexity and dependency on the network operator. However, customers looking for any of the following are expected to prefer a setup where the LoRaWAN network servers runs directly on the gateway/Azure IoT Edge: Primarily coverage on their own ground (e.g. manufacturing plants, smart buildings, facilities, ports). Capabilities that Azure IoT edge brings to the table: Local processing on the gateway. Offline capabilities of the gateway. Gateway management. Homogenous management of devices and gateways independent of connectivity technology. High Level Architecture Below is a high level diagram of how the framework works, for more details refer to the dev guide . Concepts Adaptive Data Rate Solution support Adaptive Data Rate (ADR) device management as specified in LoRa spec v1.1 . The main goal of the ADR is to optimize the network for maximum capacity ensuring devices always transmit with their best settings possible (highest DR, lowest power), you can find more ADR information on this page . Adaptive Data rate is always initiated and set on the device side. ADR should never be used with moving devices. Our implementation currently implement the Semtech proposed Algorithm for ADR and has been tested against EU868 region plan.","title":"Architecture and Concepts for the LoRaWAN starter kit"},{"location":"user-guide/architecture/#architecture-and-concepts-for-the-lorawan-starter-kit","text":"","title":"Architecture and Concepts for the LoRaWAN starter kit"},{"location":"user-guide/architecture/#background","text":"LoRaWAN is a type of wireless wide-area networking that is designed to allow long-range communication at a low bit rate among low-power connected objects, such as sensors operated on a battery. Network topology is of star-of-stars type, with the leaf sensors sending data to gateways for forwarding telemetry to and receiving commands from backing Internet services. Nowadays, even for simple scenarios like having 10 devices connected to a single LoRaWan gateway (hardware with antenna), you need to connect your gateway to a Network Server and then work through connectors provided by the server vendor to integrate your LoRa gateways and devices with the back end. These setups can be connected to Azure IoT Hub quite easily. As a matter of fact such scenarios exist . Customers looking for an operated network with national or international reach (e.g. fleet operators, logistics) will tend to choose this setup accepting the potentially higher complexity and dependency on the network operator. However, customers looking for any of the following are expected to prefer a setup where the LoRaWAN network servers runs directly on the gateway/Azure IoT Edge: Primarily coverage on their own ground (e.g. manufacturing plants, smart buildings, facilities, ports). Capabilities that Azure IoT edge brings to the table: Local processing on the gateway. Offline capabilities of the gateway. Gateway management. Homogenous management of devices and gateways independent of connectivity technology.","title":"Background"},{"location":"user-guide/architecture/#high-level-architecture","text":"Below is a high level diagram of how the framework works, for more details refer to the dev guide .","title":"High Level Architecture"},{"location":"user-guide/architecture/#concepts","text":"","title":"Concepts"},{"location":"user-guide/architecture/#adaptive-data-rate","text":"Solution support Adaptive Data Rate (ADR) device management as specified in LoRa spec v1.1 . The main goal of the ADR is to optimize the network for maximum capacity ensuring devices always transmit with their best settings possible (highest DR, lowest power), you can find more ADR information on this page . Adaptive Data rate is always initiated and set on the device side. ADR should never be used with moving devices. Our implementation currently implement the Semtech proposed Algorithm for ADR and has been tested against EU868 region plan.","title":"Adaptive Data Rate"},{"location":"user-guide/caching/","text":"Caching Function The function is utilizing a Redis cache to store device related information. It is composed of multiple cache entries: LoRaDeviceCache Stores an instance of type DeviceCacheInfo by DevEUI to keep track of FCntUp, FCntDown, GatewayId per LoRaWAN Network Server (LNS). The cache is used to have a distributed lock in a multi gateway scenario. The info per gateway is stored using the DevEUI to determine what GW is allowed to process a particular message and respond to the sending device. All the values in this cache are LoRaWAN related and don't require any other information than what we get from the device and the gateway handling a particular message. This cache needs to be reset, when a device re-joins. public class DeviceCacheInfo { public uint FCntUp { get ; set ; } public uint FCntDown { get ; set ; } public string GatewayId { get ; set ; } } iotedge-lorawan-starterkit/DeviceCacheInfo.cs at dev \u00b7 Azure/iotedge-lorawan-starterkit (github.com) LoRaDevAddrCache The LoRaDevAddrCache contains important information from the IoT Hub we require for different scenarios. Most of the information is stored in device twins that are loaded and synchronized on a predefined schedule. Twins queries have strict limits in terms of reads/device and module Understand Azure IoT Hub quotas and throttling | Microsoft Docs . Therefore this cache was put in the middle to handle the higher load we would generate to read out the information stored in IoT Hub. The cache is organized as a HSET - HSET \u2013 Redis - The key being the DevAddr and individual DevEUI as the field as multiple devices can have the same DevAddr. The values are DevAddrCacheInfo . public class DevAddrCacheInfo : IoTHubDeviceInfo { public string GatewayId { get ; set ; } public DateTime LastUpdatedTwins { get ; set ; } public string NwkSKey { get ; set ; } } public class IoTHubDeviceInfo { public string DevAddr { get ; set ; } public string DevEUI { get ; set ; } public string PrimaryKey { get ; set ; } } iotedge-lorawan-starterkit/DevAddrCacheInfo.cs at dev \u00b7 Azure/iotedge-lorawan-starterkit (github.com) This cache is automatically being populated on a schedule. We have a function trigger SyncDevAddrCache that is triggered on a regular basis (currently every 5min) to validate what synchronization is required. If the system does warm up, it will trigger a full reload. The full reload fetches all devices from the registry and synchronizes the relevant values from the twins. The sync process, does not synchronize the private key of the device from IoT hub (they will be loaded on request). The full reload will be performed at most once every 24h (unless the redis cache is completely cleared). The incremental updates do make sure we only load the delta using the timestamps on the desired and reported property: var query = $\"SELECT * FROM devices where properties.desired.$metadata.$lastUpdated >= '{lastUpdate}' OR properties.reported.$metadata.DevAddr.$lastUpdated >= '{lastUpdate}'\" ; Join related caching When we receive OTAA requests, we manage the potential of conflicting with multiple gateways as well with the redis cache. We maintain 2 caches: devnonce The devnonce keeps track of nonce values sent by the device for a join request. It makes sure the same join request is only handled once by one Gateway. The key is composed of the [DevEUI]:[DevNonce] values. It's evicted after 5min it was added to the cache. Join-info The Join-info cache contains information required when a new device joins the network. The cache is keyed by [DevEUI]:joininfo and is valid for 60min after initial creation. public class JoinInfo { public string PrimaryKey { get ; set ; } public string DesiredGateway { get ; set ; } } iotedge-lorawan-starterkit/JoinInfo.cs at dev \u00b7 Azure/iotedge-lorawan-starterkit (github.com) The DesiredGateway is used to set if a specific gateway needs to process requests coming from a device. If the value is not set, the first one to win the race, will handle the join. The PrimaryKey is used to create the device connection from the edge gateway to IoT Hub. Edge Gateway Device Cache Every device sending messages to the edge, is validated if it belongs to our network and our gateway. If it is our gateway, we build up a local representation of the device in memory including a connection to IoT Hub. The devices are cached for a specific amount of time in the LoRaDeviceRegistry . The LoRaDeviceRegistry stores the LoRaDevice with 3 entries: We maintain a dictionary by DevAddr that contains an entry per DevEUI for a particular device - valid for 2 days The device is stored directly using the DevEUI for fast lookup using deveui:[DevEUI] - no expiration When a DevAddr entry (1) is not ready, we initialize a DeviceLoaderSynchronizer to fetch matching devices from the function API. The loader itself is put in cache, to be able to handle requests, while we are in the process of loading them. - valid for 30s. Class C device cases use the DevEUI directly for downstream message sending (2). All other cases make use of the first cache by DevAddr. The Device Cache can be forcefully invalidated - Quickstart - Cache Clearing . Connections We maintain connections to the IoT hub for all devices that belong to us for which we received messages. The connection is cached per device in the LoRaDeviceClientConnectionManager . We do establish the connection to IoT hub with the PrimaryKey of the device using the standard DeviceClient Class (Microsoft.Azure.Devices.Client) - Azure for .NET Developers | Microsoft Docs . Connections are closed when the LoRaDevice is disposed.","title":"Caching"},{"location":"user-guide/caching/#caching","text":"","title":"Caching"},{"location":"user-guide/caching/#function","text":"The function is utilizing a Redis cache to store device related information. It is composed of multiple cache entries:","title":"Function"},{"location":"user-guide/caching/#loradevicecache","text":"Stores an instance of type DeviceCacheInfo by DevEUI to keep track of FCntUp, FCntDown, GatewayId per LoRaWAN Network Server (LNS). The cache is used to have a distributed lock in a multi gateway scenario. The info per gateway is stored using the DevEUI to determine what GW is allowed to process a particular message and respond to the sending device. All the values in this cache are LoRaWAN related and don't require any other information than what we get from the device and the gateway handling a particular message. This cache needs to be reset, when a device re-joins. public class DeviceCacheInfo { public uint FCntUp { get ; set ; } public uint FCntDown { get ; set ; } public string GatewayId { get ; set ; } } iotedge-lorawan-starterkit/DeviceCacheInfo.cs at dev \u00b7 Azure/iotedge-lorawan-starterkit (github.com)","title":"LoRaDeviceCache"},{"location":"user-guide/caching/#loradevaddrcache","text":"The LoRaDevAddrCache contains important information from the IoT Hub we require for different scenarios. Most of the information is stored in device twins that are loaded and synchronized on a predefined schedule. Twins queries have strict limits in terms of reads/device and module Understand Azure IoT Hub quotas and throttling | Microsoft Docs . Therefore this cache was put in the middle to handle the higher load we would generate to read out the information stored in IoT Hub. The cache is organized as a HSET - HSET \u2013 Redis - The key being the DevAddr and individual DevEUI as the field as multiple devices can have the same DevAddr. The values are DevAddrCacheInfo . public class DevAddrCacheInfo : IoTHubDeviceInfo { public string GatewayId { get ; set ; } public DateTime LastUpdatedTwins { get ; set ; } public string NwkSKey { get ; set ; } } public class IoTHubDeviceInfo { public string DevAddr { get ; set ; } public string DevEUI { get ; set ; } public string PrimaryKey { get ; set ; } } iotedge-lorawan-starterkit/DevAddrCacheInfo.cs at dev \u00b7 Azure/iotedge-lorawan-starterkit (github.com) This cache is automatically being populated on a schedule. We have a function trigger SyncDevAddrCache that is triggered on a regular basis (currently every 5min) to validate what synchronization is required. If the system does warm up, it will trigger a full reload. The full reload fetches all devices from the registry and synchronizes the relevant values from the twins. The sync process, does not synchronize the private key of the device from IoT hub (they will be loaded on request). The full reload will be performed at most once every 24h (unless the redis cache is completely cleared). The incremental updates do make sure we only load the delta using the timestamps on the desired and reported property: var query = $\"SELECT * FROM devices where properties.desired.$metadata.$lastUpdated >= '{lastUpdate}' OR properties.reported.$metadata.DevAddr.$lastUpdated >= '{lastUpdate}'\" ;","title":"LoRaDevAddrCache"},{"location":"user-guide/caching/#join-related-caching","text":"When we receive OTAA requests, we manage the potential of conflicting with multiple gateways as well with the redis cache. We maintain 2 caches:","title":"Join related caching"},{"location":"user-guide/caching/#devnonce","text":"The devnonce keeps track of nonce values sent by the device for a join request. It makes sure the same join request is only handled once by one Gateway. The key is composed of the [DevEUI]:[DevNonce] values. It's evicted after 5min it was added to the cache.","title":"devnonce"},{"location":"user-guide/caching/#join-info","text":"The Join-info cache contains information required when a new device joins the network. The cache is keyed by [DevEUI]:joininfo and is valid for 60min after initial creation. public class JoinInfo { public string PrimaryKey { get ; set ; } public string DesiredGateway { get ; set ; } } iotedge-lorawan-starterkit/JoinInfo.cs at dev \u00b7 Azure/iotedge-lorawan-starterkit (github.com) The DesiredGateway is used to set if a specific gateway needs to process requests coming from a device. If the value is not set, the first one to win the race, will handle the join. The PrimaryKey is used to create the device connection from the edge gateway to IoT Hub.","title":"Join-info"},{"location":"user-guide/caching/#edge-gateway","text":"","title":"Edge Gateway"},{"location":"user-guide/caching/#device-cache","text":"Every device sending messages to the edge, is validated if it belongs to our network and our gateway. If it is our gateway, we build up a local representation of the device in memory including a connection to IoT Hub. The devices are cached for a specific amount of time in the LoRaDeviceRegistry . The LoRaDeviceRegistry stores the LoRaDevice with 3 entries: We maintain a dictionary by DevAddr that contains an entry per DevEUI for a particular device - valid for 2 days The device is stored directly using the DevEUI for fast lookup using deveui:[DevEUI] - no expiration When a DevAddr entry (1) is not ready, we initialize a DeviceLoaderSynchronizer to fetch matching devices from the function API. The loader itself is put in cache, to be able to handle requests, while we are in the process of loading them. - valid for 30s. Class C device cases use the DevEUI directly for downstream message sending (2). All other cases make use of the first cache by DevAddr. The Device Cache can be forcefully invalidated - Quickstart - Cache Clearing .","title":"Device Cache"},{"location":"user-guide/caching/#connections","text":"We maintain connections to the IoT hub for all devices that belong to us for which we received messages. The connection is cached per device in the LoRaDeviceClientConnectionManager . We do establish the connection to IoT hub with the PrimaryKey of the device using the standard DeviceClient Class (Microsoft.Azure.Devices.Client) - Azure for .NET Developers | Microsoft Docs . Connections are closed when the LoRaDevice is disposed.","title":"Connections"},{"location":"user-guide/devguide/","text":"Developer Guidance Directory Structure The code is organized into three sections: LoRaEngine - a .NET core 3.1 solution with the following folders: modules - Azure IoT Edge modules. LoraKeysManagerFacade - An Azure function handling device provisioning (e.g. LoRa network join, OTAA) with Azure IoT Hub as persistence layer. LoRaDevTools - library for dev tools (git submodule) Arduino - Examples and references for LoRa Arduino based devices. Template - Contain code useful for the \"deploy to Azure button\" Tools - Contains tools that support the LoRaWan Gateway project Cli-LoRa-Device-Provisioning - .NET Core 2.1 Command Line tool that allows to list, query, verify, insert, edit, update and delete LoRa leaf device configurations into IoT Hub Samples - Contains sample decoders Docs - Additional modules, pictures and documentations LoRaEngine A .NET Core 3.1 solution with the following projects: modules - Azure IoT Edge modules. LoRaBasicsStationModule packages the Basics Station into an IoT Edge compatible docker container. See https://github.com/lorabasics/basicstation . If you are using a RAK833-USB you need to build your own Basics Station docker image starting from the fork at this link LoRaWanNetworkSrvModule - is the LoRaWAN network server implementation. LoraKeysManagerFacade - An Azure function handling device provisioning (e.g. LoRa network join, OTAA) with Azure IoT Hub as persistence layer. LoRaDevTools - library for dev tools (git submodule) The overall architecture This schema represent the various components and how they interact to have a better understand of the various solution elements. Once the IoT Edge engine start on the Edge device, the code modules are downloaded from the Azure Container Registry. The module containing the LoRaWan network server is downloaded on the Edge device The LoRaWan Network Server request status for the LoRa devices. The Azure Function LoraKeysManagerFacade is used to aquire the device identity from IoT Hub. In the case you're using the demo device with the automatic deployment Azure Resource Manager (ARM) template: the Azure function LoraKeysManagerFacade will register the device 47AAC86800430028 into the Azure IoT Hub for you. Otherwise you need to provision a device yourself in IoT Hub: device provisioning The Azure function LoraKeysManagerFacade sends back the device identity to the module The LoRaWan Network Server module: instantiate the device on the LoRa Gateway if needed gather the LoRa sensor data from the LoRaWan gateway thru the LoRa Basics\u2122 Station decode the LoRa data if requested Publish the LoRa sensor data to Azure IoT Hub Another view of the architecture and a more message driven view is the following: Getting started with: Build and deploy LoRaEngine The following guide describes the necessary steps to build and deploy the LoRaEngine to an Azure IoT Edge installation on a LoRaWAN antenna gateway. If you want to update a LoRa Gateway running a previous version fo our software to the current release, follow this guide Used Azure services Azure IoT Hub Azure Container registry Azure Functions Redis Cache Azure Monitor Prerequisites Have LoRaWAN concentrator and edge node hardware ready for testing. The LoRaEngine has been tested and build for various hardware setups. However, for this guide we used the Seeed LoRa/LoRaWAN Gateway Kit and concentrator and the Seeeduino LoRaWAN as edge node. Installed Azure IoT Edge on your LoRaWAN concentrator enabled edge device. SetUp an Azure IoT Hub instance and be familiar with Azure IoT Edge module deployment mechanism. Be familiar with Azure IoT Edge module development . Note: the following guide expects that your modules will be pushed to Azure Container registry . Create a new IoT Edge device in you IoT Hub with a name of your choice and the default settings. Create Redis Cache Create a Redis Cache in your resource group and the region you are using with a DNS Name of your choice and of the size Standard C0 . Leave all other settings unchanged. Navigate to your Redis Cache and from Settings -> Access Keys, note the Primary connection string (StackExchange.Redis) . Setup Azure function facade and Azure Container registry You have the option to either deploy the Azure Function code from your Visual Studio Code to Azure or create an empty Azure Function that points to a Zip file hosted by us, containing the function code. Follow one of the two sets of instructions that follow: Deploy manually using Visual Studio On your Visual Studio Solution, right click on the 'LoRaKeysManagerFacade' project, select 'deploy', then 'Azure' and then 'Azure function'. You should then arrive on a page where you just need to hit the deploy button to get the code deployed on Azure. Deploy manually using Visual Studio Code Open the Azure function folder with Visual Studio Code with the Azure Functions Plugin installed. Now run the command Azure Functions: Deploy to function app... and provide the name of the Azure function to deploy to. If prompted, select environment C# and version V3 . If you want to just deploy the function from Visual Studio Code with the root project folder iotedge-lorawan-starterkit open (of which the Function is a subfolder /LoRaEngine/LoraKeysManagerFacade ), you need to run the Visual Studio Command Azure Functions: Deploy to function app... and then manually choose the folder LoraKeysManagerFacade/bin/Release/netcoreapp3.1/publish . (Unfortunately at time of this writing we saw the behavior that VSCode is proposing the wrong folder). Building the function does not work in this way unfortunately. If you choose to create an empty Azure Function pointing to our Zipped code Using the Azure Portal, create a new \"Function App\" in the resource group and location you chose for the deployment, using the default creation settings. Once the function is created, navigate to the Application settings from the Overview page. Add a new Application Setting with: App Settings Name Value WEBSITE_RUN_FROM_ZIP https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.4/function-1.0.4.zip Follow these next steps in both cases Configure IoT Hub and Redis connection strings in the function: Copy your Redis Cache connection string in a connection string names RedisConnectionString Copy your IoT Hub Connection string with owner policy applied: Now paste it into Application settings -> Connection strings as IoTHubConnectionString of type Custom : Also, add the previously saved Primary connection string (StackExchange.Redis) from your Redis Cache to the Connection strings of your function. Use type Custom again. From the Facade Azure function, extract the Host key of type _master and save it somewhere. (We will need it in the next step) Create your .env file in the /LoRaEngine folder by copying the example.env file located here Configure your .env file with your own Azure Container registry as well as the Facade access URL and credentials. Set the region to \"EU\" or \"US\" based on your location. You do not need to change any of the other settings at this point. Those variables will be used by our Azure IoT Edge solution template . ... CONTAINER_REGISTRY_ADDRESS=yourregistry.azurecr.io CONTAINER_REGISTRY_USERNAME=yourlogin CONTAINER_REGISTRY_PASSWORD=registrypassword ... REGION=EU ... FACADE_SERVER_URL=https://yourfunction.azurewebsites.net/api/ FACADE_AUTH_CODE=yourfunctionpassword ... Use a Proxy server to connect your Concentrator to Azure This step is optional and should only be executed if your concentrator needs to use a proxy server to communicate with Azure Follow the guide on configuring an IoT Edge device to communicate through a proxy server to: Configure the Docker daemon and the IoT Edge daemon on your device to use a proxy server. Configure the edgeAgent properties in the config.yaml file on your device. Set environment variables for the IoT Edge runtime in the deployment manifest. After that, add the environment variable https_proxy to the LoRaWanNetworkSrvModule in your IoT Hub \u2192 IoT Edge \u2192 Edge Device \u2192 Set Modules section. End of optional proxy configuration Setup concentrator with Azure IoT Edge Note: if your LoRa chip set is connected by SPI on raspberry PI bus don't forget to enable it , (You need to restart your pi). Build and deploy Azure IoT Edge solution We will use Azure IoT Edge for Visual Studio Code extension to build, push and deploy our solution. Make sure you are logged in to the Azure Container Registry you are using. Run docker login <mycontainerregistry>.azurecr.io on your development machine. Select the architecture of your gateway (Azure IoT Edge Solution Default Platform) by clicking on the button in the taskbar and selecting amd64 or arm32v7 in the command pallette. Now, build an push the solution by right clicking deployment.template.json and select Build and Push IoT Edge Solution . After that you can push the solution to your IoT Edge device by right clicking on the device and selecting Create Deployment for single device . In the file dialog, navigate to the LoRaEngine\\config folder and select the deployment.json file which was created during the previous step. Provision LoRa leaf device The sample code used in this example is based on Seeeduino LoRaWAN with a Grove - Temperature Sensor . It sends every 30 seconds its current temperature reading and prints out a Cloud-2-Device message if one is transmitted in its receive window. The sample has configured the following sample device identifiers and credentials : DevEUI: 47AAC86800430010 AppEUI: BE7A0000000014E3 AppKey: 8AFE71A145B253E49C3031AD068277A3 You will need your own identifiers when provisioning the device. Look out for these code lines: lora . setId ( NULL , \"47AAC86800430010\" , \"BE7A0000000014E3\" ); lora . setKey ( NULL , NULL , \"8AFE71A145B253E49C3031AD068277A3\" ); To provisioning a device in Azure IoT Hub with these identifiers and capable to decode simple value payload into Json you have to create a device with: Device Id: 47AAC86800430010 and Device Twin's deired properties: \"desired\" : { \"AppEUI\" : \"BE7A0000000014E3\" , \"AppKey\" : \"8AFE71A145B253E49C3031AD068277A3\" , \"SensorDecoder\" : \"DecoderValueSensor\" } You can provision the device manually in the Azure portal or use the provided Command Line Interface Provisioning Tool to list, query, verify add, update, and remove devices . The command to execute is: dotnet run -- add - -type OTAA - -deveui 47AAC86800430010 - -appeui BE7A0000000014E3 - -appkey 8AFE71A145B253E49C3031AD068277A3 - -decoder DecoderValueSensor To manually provision the device in IoT Hub, do the following: Device to Cloud and Cloud to Device messaging in action As soon as you start your device you should see the following: DevAddr, AppSKey and NwkSKey are generated and stored in the Device Twin, e.g.: \"desired\" : { \"AppEUI\" : \"BE7A0000000014E3\" , \"AppKey\" : \"8AFE71A145B253E49C3031AD068277A3\" , \"SensorDecoder\" : \"DecoderValueSensor\" , \"AppSKey\" : \"5E8513F64D99A63753A5F0DBB9FB9F91\" , \"NwkSKey\" : \"C0EF4B9495BD4A4C32B42438CD52D4B8\" , \"DevAddr\" : \"025DEAAE\" , \"DevNonce\" : \"D9B6\" } If you follow the logs of the network server module (e.g. sudo iotedge logs LoRaWanNetworkSrvModule -f ) you can follow the LoRa device join: {\"rxpk\":[{\"tmst\":3831950603,\"chan\":2,\"rfch\":1,\"freq\":868.500000,\"stat\":1,\"modu\":\"LORA\",\"datr\":\"SF7BW125\",\"codr\":\"4/5\",\"lsnr\":8.5,\"rssi\":-30,\"size\":23,\"data\":\"AOMUAAAAAHq+EABDAGjIqkfZtkroyCc=\"}]} Join Request Received {\"txpk\":{\"imme\":false,\"data\":\"IE633dznxvgA89ZTkH1jET0=\",\"tmst\":3836950603,\"size\":17,\"freq\":868.5,\"rfch\":0,\"modu\":\"LORA\",\"datr\":\"SF7BW125\",\"codr\":\"4/5\",\"powe\":14,\"ipol\":true}} Using edgeHub as local queue Updating twins... Join Accept sent TX ACK RECEIVED Every 30 seconds the temperature is transmitted by the device, e.g.: { \"time\" : null , \"tmms\" : 0 , \"tmst\" : 4226472308 , \"freq\" : 868.5 , \"chan\" : 2 , \"rfch\" : 1 , \"stat\" : 1 , \"modu\" : \"LORA\" , \"datr\" : \"SF12BW125\" , \"codr\" : \"4/5\" , \"rssi\" : -33 , \"lsnr\" : 7.5 , \"size\" : 18 , \"data\" : { \"temperature\" : 18.78 }, \"EUI\" : \"47AAC86800430010\" , \"gatewayId\" : \"berry2\" , \"edgets\" : 1534253192857 } Note: an easy way to follow messages send from the device is again with VSCode: right click on the device in the explorer -> Start Monitoring D2C Message . This is how a complete transmission looks like: You can even test sending Cloud-2-Device message (e.g. by VSCode right click on the device in the explorer -> Send C2D Message To Device ). The Arduino example provided above will print the message on the console. Keep in mind that a LoRaWAN Class A device will only receive after a transmit, in our case every 30 seconds. Observability We support Azure Monitor for observability of the LoRaWAN starter kit. If you decide to use Azure Monitor, you will need to create an Application Insights instance and a Log Analytics workspace in your subscription. To enable observability, modify the following settings in your .env file: APPINSIGHTS_INSTRUMENTATIONKEY={appinsight_key} IOT_HUB_RESOURCE_ID=/subscriptions/{subscription_id}/resourceGroups/{resource_group}/providers/Microsoft.Devices/IotHubs/{iot_hub_name} LOG_ANALYTICS_WORKSPACE_ID={log_analytics_workspace_id} LOG_ANALYTICS_SHARED_KEY={log_analytics_shared_key} Generate a deployment manifest from deployment_observability.layered.template.json and deploy it to the edge devices for which you want to apply the observability. The template will set up the metrics collector module on the edge and connect it with your Log Analytics instance. The gateway will connect to your Application Insights instance. Make sure to set the APPINSIGHTS_INSTRUMENTATIONKEY before deploying the deployment.template.lbs.json solution, if you want to make sure that the gateway can connect to Application Insights. The Application Insights log level will always be the same as the console log level. The Network Server will always expose metrics in Prometheus format at the path /metrics . You can scrape these metrics using the tool of you choice. Debugging in Visual Studio, outside of IoT Edge and Docker It is possible to run the LoRaEngine locally from Visual Studio in order to enable a better debugging experience. Here are the steps you will need to follow in order to enable this feature: Either change the value server_adress in the file local_conf.json (located in LoRaEngine/modules/LoRaWanPktFwdModule) to point to your computer. Rebuild and redeploy the container. Alternatively , configure your unmodified LoRaWanPktFwdModule Docker container / Edge module with the environment variable NETWORK_SERVER=<ip of your computer> If you are using a Wireless network in Windows, make sure it is configured as a private network in your Windows settings. Otherwise, the Windows Firewall will bock the incoming UDP packets. Open the properties of the project LoRaWanNetworkServerModule and set the following Environment Variables under the Debug tab: IOTEDGE_IOTHUBHOSTNAME : XXX.azure-devices.net (XXX = your iot hub hostname) ENABLE_GATEWAY : false LOG_LEVEL : 1 or Debug (optional, to activate most verbose logging level) FACADE_SERVER_URL : http://localhost:7071/api/ (when debugging locally or any other URL of the Azure function you want to use) IOTEDGE_DEVICEID : The Name of your PC Add a local.settings.json file to the project LoRaKeysManagerFacade containing: { \"IsEncrypted\" : false , \"values\" : { \"AzureWebJobsStorage\" : \"<Connection String of your deployed blob storage>\" , \"WEBSITE_CONTENTSHARE\" : \"<Name of your Azure function>\" }, \"ConnectionStrings\" : { \"IoTHubConnectionString\" : \"<Connection string of your IoT Hub Owner (go to keys -> IoT Hub owner and select the connection string)>\" , \"RedisConnectionString\" : \"<Connection string of your Redis Cache>\" } } Right click on your solution and select properties, select multiple startup projects. Start LoRaWanNetworkSrvModule and LoRaKeysManagerFacade . If you hit start in your VS solution, you will receive messages directly from your LoRa Basics\u2122 Station. You will be able to debug directly from your computer. Happy Debugging!","title":"Developer Guidance"},{"location":"user-guide/devguide/#developer-guidance","text":"","title":"Developer Guidance"},{"location":"user-guide/devguide/#directory-structure","text":"The code is organized into three sections: LoRaEngine - a .NET core 3.1 solution with the following folders: modules - Azure IoT Edge modules. LoraKeysManagerFacade - An Azure function handling device provisioning (e.g. LoRa network join, OTAA) with Azure IoT Hub as persistence layer. LoRaDevTools - library for dev tools (git submodule) Arduino - Examples and references for LoRa Arduino based devices. Template - Contain code useful for the \"deploy to Azure button\" Tools - Contains tools that support the LoRaWan Gateway project Cli-LoRa-Device-Provisioning - .NET Core 2.1 Command Line tool that allows to list, query, verify, insert, edit, update and delete LoRa leaf device configurations into IoT Hub Samples - Contains sample decoders Docs - Additional modules, pictures and documentations","title":"Directory Structure"},{"location":"user-guide/devguide/#loraengine","text":"A .NET Core 3.1 solution with the following projects: modules - Azure IoT Edge modules. LoRaBasicsStationModule packages the Basics Station into an IoT Edge compatible docker container. See https://github.com/lorabasics/basicstation . If you are using a RAK833-USB you need to build your own Basics Station docker image starting from the fork at this link LoRaWanNetworkSrvModule - is the LoRaWAN network server implementation. LoraKeysManagerFacade - An Azure function handling device provisioning (e.g. LoRa network join, OTAA) with Azure IoT Hub as persistence layer. LoRaDevTools - library for dev tools (git submodule)","title":"LoRaEngine"},{"location":"user-guide/devguide/#the-overall-architecture","text":"This schema represent the various components and how they interact to have a better understand of the various solution elements. Once the IoT Edge engine start on the Edge device, the code modules are downloaded from the Azure Container Registry. The module containing the LoRaWan network server is downloaded on the Edge device The LoRaWan Network Server request status for the LoRa devices. The Azure Function LoraKeysManagerFacade is used to aquire the device identity from IoT Hub. In the case you're using the demo device with the automatic deployment Azure Resource Manager (ARM) template: the Azure function LoraKeysManagerFacade will register the device 47AAC86800430028 into the Azure IoT Hub for you. Otherwise you need to provision a device yourself in IoT Hub: device provisioning The Azure function LoraKeysManagerFacade sends back the device identity to the module The LoRaWan Network Server module: instantiate the device on the LoRa Gateway if needed gather the LoRa sensor data from the LoRaWan gateway thru the LoRa Basics\u2122 Station decode the LoRa data if requested Publish the LoRa sensor data to Azure IoT Hub Another view of the architecture and a more message driven view is the following:","title":"The overall architecture"},{"location":"user-guide/devguide/#getting-started-with-build-and-deploy-loraengine","text":"The following guide describes the necessary steps to build and deploy the LoRaEngine to an Azure IoT Edge installation on a LoRaWAN antenna gateway. If you want to update a LoRa Gateway running a previous version fo our software to the current release, follow this guide","title":"Getting started with: Build and deploy LoRaEngine"},{"location":"user-guide/devguide/#used-azure-services","text":"Azure IoT Hub Azure Container registry Azure Functions Redis Cache Azure Monitor","title":"Used Azure services"},{"location":"user-guide/devguide/#prerequisites","text":"Have LoRaWAN concentrator and edge node hardware ready for testing. The LoRaEngine has been tested and build for various hardware setups. However, for this guide we used the Seeed LoRa/LoRaWAN Gateway Kit and concentrator and the Seeeduino LoRaWAN as edge node. Installed Azure IoT Edge on your LoRaWAN concentrator enabled edge device. SetUp an Azure IoT Hub instance and be familiar with Azure IoT Edge module deployment mechanism. Be familiar with Azure IoT Edge module development . Note: the following guide expects that your modules will be pushed to Azure Container registry . Create a new IoT Edge device in you IoT Hub with a name of your choice and the default settings.","title":"Prerequisites"},{"location":"user-guide/devguide/#create-redis-cache","text":"Create a Redis Cache in your resource group and the region you are using with a DNS Name of your choice and of the size Standard C0 . Leave all other settings unchanged. Navigate to your Redis Cache and from Settings -> Access Keys, note the Primary connection string (StackExchange.Redis) .","title":"Create Redis Cache"},{"location":"user-guide/devguide/#setup-azure-function-facade-and-azure-container-registry","text":"You have the option to either deploy the Azure Function code from your Visual Studio Code to Azure or create an empty Azure Function that points to a Zip file hosted by us, containing the function code. Follow one of the two sets of instructions that follow:","title":"Setup Azure function facade and Azure Container registry"},{"location":"user-guide/devguide/#deploy-manually-using-visual-studio","text":"On your Visual Studio Solution, right click on the 'LoRaKeysManagerFacade' project, select 'deploy', then 'Azure' and then 'Azure function'. You should then arrive on a page where you just need to hit the deploy button to get the code deployed on Azure.","title":"Deploy manually using Visual Studio"},{"location":"user-guide/devguide/#deploy-manually-using-visual-studio-code","text":"Open the Azure function folder with Visual Studio Code with the Azure Functions Plugin installed. Now run the command Azure Functions: Deploy to function app... and provide the name of the Azure function to deploy to. If prompted, select environment C# and version V3 . If you want to just deploy the function from Visual Studio Code with the root project folder iotedge-lorawan-starterkit open (of which the Function is a subfolder /LoRaEngine/LoraKeysManagerFacade ), you need to run the Visual Studio Command Azure Functions: Deploy to function app... and then manually choose the folder LoraKeysManagerFacade/bin/Release/netcoreapp3.1/publish . (Unfortunately at time of this writing we saw the behavior that VSCode is proposing the wrong folder). Building the function does not work in this way unfortunately.","title":"Deploy manually using Visual Studio Code"},{"location":"user-guide/devguide/#if-you-choose-to-create-an-empty-azure-function-pointing-to-our-zipped-code","text":"Using the Azure Portal, create a new \"Function App\" in the resource group and location you chose for the deployment, using the default creation settings. Once the function is created, navigate to the Application settings from the Overview page. Add a new Application Setting with: App Settings Name Value WEBSITE_RUN_FROM_ZIP https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.4/function-1.0.4.zip","title":"If you choose to create an empty Azure Function pointing to our Zipped code"},{"location":"user-guide/devguide/#follow-these-next-steps-in-both-cases","text":"Configure IoT Hub and Redis connection strings in the function: Copy your Redis Cache connection string in a connection string names RedisConnectionString Copy your IoT Hub Connection string with owner policy applied: Now paste it into Application settings -> Connection strings as IoTHubConnectionString of type Custom : Also, add the previously saved Primary connection string (StackExchange.Redis) from your Redis Cache to the Connection strings of your function. Use type Custom again. From the Facade Azure function, extract the Host key of type _master and save it somewhere. (We will need it in the next step) Create your .env file in the /LoRaEngine folder by copying the example.env file located here Configure your .env file with your own Azure Container registry as well as the Facade access URL and credentials. Set the region to \"EU\" or \"US\" based on your location. You do not need to change any of the other settings at this point. Those variables will be used by our Azure IoT Edge solution template . ... CONTAINER_REGISTRY_ADDRESS=yourregistry.azurecr.io CONTAINER_REGISTRY_USERNAME=yourlogin CONTAINER_REGISTRY_PASSWORD=registrypassword ... REGION=EU ... FACADE_SERVER_URL=https://yourfunction.azurewebsites.net/api/ FACADE_AUTH_CODE=yourfunctionpassword ...","title":"Follow these next steps in both cases"},{"location":"user-guide/devguide/#use-a-proxy-server-to-connect-your-concentrator-to-azure","text":"This step is optional and should only be executed if your concentrator needs to use a proxy server to communicate with Azure Follow the guide on configuring an IoT Edge device to communicate through a proxy server to: Configure the Docker daemon and the IoT Edge daemon on your device to use a proxy server. Configure the edgeAgent properties in the config.yaml file on your device. Set environment variables for the IoT Edge runtime in the deployment manifest. After that, add the environment variable https_proxy to the LoRaWanNetworkSrvModule in your IoT Hub \u2192 IoT Edge \u2192 Edge Device \u2192 Set Modules section. End of optional proxy configuration","title":"Use a Proxy server to connect your Concentrator to Azure"},{"location":"user-guide/devguide/#setup-concentrator-with-azure-iot-edge","text":"Note: if your LoRa chip set is connected by SPI on raspberry PI bus don't forget to enable it , (You need to restart your pi). Build and deploy Azure IoT Edge solution We will use Azure IoT Edge for Visual Studio Code extension to build, push and deploy our solution. Make sure you are logged in to the Azure Container Registry you are using. Run docker login <mycontainerregistry>.azurecr.io on your development machine. Select the architecture of your gateway (Azure IoT Edge Solution Default Platform) by clicking on the button in the taskbar and selecting amd64 or arm32v7 in the command pallette. Now, build an push the solution by right clicking deployment.template.json and select Build and Push IoT Edge Solution . After that you can push the solution to your IoT Edge device by right clicking on the device and selecting Create Deployment for single device . In the file dialog, navigate to the LoRaEngine\\config folder and select the deployment.json file which was created during the previous step.","title":"Setup concentrator with Azure IoT Edge"},{"location":"user-guide/devguide/#provision-lora-leaf-device","text":"The sample code used in this example is based on Seeeduino LoRaWAN with a Grove - Temperature Sensor . It sends every 30 seconds its current temperature reading and prints out a Cloud-2-Device message if one is transmitted in its receive window. The sample has configured the following sample device identifiers and credentials : DevEUI: 47AAC86800430010 AppEUI: BE7A0000000014E3 AppKey: 8AFE71A145B253E49C3031AD068277A3 You will need your own identifiers when provisioning the device. Look out for these code lines: lora . setId ( NULL , \"47AAC86800430010\" , \"BE7A0000000014E3\" ); lora . setKey ( NULL , NULL , \"8AFE71A145B253E49C3031AD068277A3\" ); To provisioning a device in Azure IoT Hub with these identifiers and capable to decode simple value payload into Json you have to create a device with: Device Id: 47AAC86800430010 and Device Twin's deired properties: \"desired\" : { \"AppEUI\" : \"BE7A0000000014E3\" , \"AppKey\" : \"8AFE71A145B253E49C3031AD068277A3\" , \"SensorDecoder\" : \"DecoderValueSensor\" } You can provision the device manually in the Azure portal or use the provided Command Line Interface Provisioning Tool to list, query, verify add, update, and remove devices . The command to execute is: dotnet run -- add - -type OTAA - -deveui 47AAC86800430010 - -appeui BE7A0000000014E3 - -appkey 8AFE71A145B253E49C3031AD068277A3 - -decoder DecoderValueSensor To manually provision the device in IoT Hub, do the following:","title":"Provision LoRa leaf device"},{"location":"user-guide/devguide/#device-to-cloud-and-cloud-to-device-messaging-in-action","text":"As soon as you start your device you should see the following: DevAddr, AppSKey and NwkSKey are generated and stored in the Device Twin, e.g.: \"desired\" : { \"AppEUI\" : \"BE7A0000000014E3\" , \"AppKey\" : \"8AFE71A145B253E49C3031AD068277A3\" , \"SensorDecoder\" : \"DecoderValueSensor\" , \"AppSKey\" : \"5E8513F64D99A63753A5F0DBB9FB9F91\" , \"NwkSKey\" : \"C0EF4B9495BD4A4C32B42438CD52D4B8\" , \"DevAddr\" : \"025DEAAE\" , \"DevNonce\" : \"D9B6\" } If you follow the logs of the network server module (e.g. sudo iotedge logs LoRaWanNetworkSrvModule -f ) you can follow the LoRa device join: {\"rxpk\":[{\"tmst\":3831950603,\"chan\":2,\"rfch\":1,\"freq\":868.500000,\"stat\":1,\"modu\":\"LORA\",\"datr\":\"SF7BW125\",\"codr\":\"4/5\",\"lsnr\":8.5,\"rssi\":-30,\"size\":23,\"data\":\"AOMUAAAAAHq+EABDAGjIqkfZtkroyCc=\"}]} Join Request Received {\"txpk\":{\"imme\":false,\"data\":\"IE633dznxvgA89ZTkH1jET0=\",\"tmst\":3836950603,\"size\":17,\"freq\":868.5,\"rfch\":0,\"modu\":\"LORA\",\"datr\":\"SF7BW125\",\"codr\":\"4/5\",\"powe\":14,\"ipol\":true}} Using edgeHub as local queue Updating twins... Join Accept sent TX ACK RECEIVED Every 30 seconds the temperature is transmitted by the device, e.g.: { \"time\" : null , \"tmms\" : 0 , \"tmst\" : 4226472308 , \"freq\" : 868.5 , \"chan\" : 2 , \"rfch\" : 1 , \"stat\" : 1 , \"modu\" : \"LORA\" , \"datr\" : \"SF12BW125\" , \"codr\" : \"4/5\" , \"rssi\" : -33 , \"lsnr\" : 7.5 , \"size\" : 18 , \"data\" : { \"temperature\" : 18.78 }, \"EUI\" : \"47AAC86800430010\" , \"gatewayId\" : \"berry2\" , \"edgets\" : 1534253192857 } Note: an easy way to follow messages send from the device is again with VSCode: right click on the device in the explorer -> Start Monitoring D2C Message . This is how a complete transmission looks like: You can even test sending Cloud-2-Device message (e.g. by VSCode right click on the device in the explorer -> Send C2D Message To Device ). The Arduino example provided above will print the message on the console. Keep in mind that a LoRaWAN Class A device will only receive after a transmit, in our case every 30 seconds.","title":"Device to Cloud and Cloud to Device messaging in action"},{"location":"user-guide/devguide/#observability","text":"We support Azure Monitor for observability of the LoRaWAN starter kit. If you decide to use Azure Monitor, you will need to create an Application Insights instance and a Log Analytics workspace in your subscription. To enable observability, modify the following settings in your .env file: APPINSIGHTS_INSTRUMENTATIONKEY={appinsight_key} IOT_HUB_RESOURCE_ID=/subscriptions/{subscription_id}/resourceGroups/{resource_group}/providers/Microsoft.Devices/IotHubs/{iot_hub_name} LOG_ANALYTICS_WORKSPACE_ID={log_analytics_workspace_id} LOG_ANALYTICS_SHARED_KEY={log_analytics_shared_key} Generate a deployment manifest from deployment_observability.layered.template.json and deploy it to the edge devices for which you want to apply the observability. The template will set up the metrics collector module on the edge and connect it with your Log Analytics instance. The gateway will connect to your Application Insights instance. Make sure to set the APPINSIGHTS_INSTRUMENTATIONKEY before deploying the deployment.template.lbs.json solution, if you want to make sure that the gateway can connect to Application Insights. The Application Insights log level will always be the same as the console log level. The Network Server will always expose metrics in Prometheus format at the path /metrics . You can scrape these metrics using the tool of you choice.","title":"Observability"},{"location":"user-guide/devguide/#debugging-in-visual-studio-outside-of-iot-edge-and-docker","text":"It is possible to run the LoRaEngine locally from Visual Studio in order to enable a better debugging experience. Here are the steps you will need to follow in order to enable this feature: Either change the value server_adress in the file local_conf.json (located in LoRaEngine/modules/LoRaWanPktFwdModule) to point to your computer. Rebuild and redeploy the container. Alternatively , configure your unmodified LoRaWanPktFwdModule Docker container / Edge module with the environment variable NETWORK_SERVER=<ip of your computer> If you are using a Wireless network in Windows, make sure it is configured as a private network in your Windows settings. Otherwise, the Windows Firewall will bock the incoming UDP packets. Open the properties of the project LoRaWanNetworkServerModule and set the following Environment Variables under the Debug tab: IOTEDGE_IOTHUBHOSTNAME : XXX.azure-devices.net (XXX = your iot hub hostname) ENABLE_GATEWAY : false LOG_LEVEL : 1 or Debug (optional, to activate most verbose logging level) FACADE_SERVER_URL : http://localhost:7071/api/ (when debugging locally or any other URL of the Azure function you want to use) IOTEDGE_DEVICEID : The Name of your PC Add a local.settings.json file to the project LoRaKeysManagerFacade containing: { \"IsEncrypted\" : false , \"values\" : { \"AzureWebJobsStorage\" : \"<Connection String of your deployed blob storage>\" , \"WEBSITE_CONTENTSHARE\" : \"<Name of your Azure function>\" }, \"ConnectionStrings\" : { \"IoTHubConnectionString\" : \"<Connection string of your IoT Hub Owner (go to keys -> IoT Hub owner and select the connection string)>\" , \"RedisConnectionString\" : \"<Connection string of your Redis Cache>\" } } Right click on your solution and select properties, select multiple startup projects. Start LoRaWanNetworkSrvModule and LoRaKeysManagerFacade . If you hit start in your VS solution, you will receive messages directly from your LoRa Basics\u2122 Station. You will be able to debug directly from your computer. Happy Debugging!","title":"Debugging in Visual Studio, outside of IoT Edge and Docker"},{"location":"user-guide/documentation/","text":"Working with the documentation This documentation site is built using MkDocs and mkdocs-material . The static documentation is built from the docs/main branch in the GitHub repository. Working locally Checkout the branch that contains the documentation: git worktree > git checkout docs/main # If you want to have `dev` branch and `docs` branch side by side, # try out git worktree # from the working folder: > git worktree add c:/path-to-sources/lorawan.docs docs/main The recommended approach is using docker to serve the static site locally: serve documentation locally > docker pull squidfunk/mkdocs-material # in the folder where the `docs/main` branch lives locally: > docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material Now you can see the site running locally on http://localhost:8080 . You can change the port in the docker run command.","title":"Working with the documentation"},{"location":"user-guide/documentation/#working-with-the-documentation","text":"This documentation site is built using MkDocs and mkdocs-material . The static documentation is built from the docs/main branch in the GitHub repository.","title":"Working with the documentation"},{"location":"user-guide/documentation/#working-locally","text":"Checkout the branch that contains the documentation: git worktree > git checkout docs/main # If you want to have `dev` branch and `docs` branch side by side, # try out git worktree # from the working folder: > git worktree add c:/path-to-sources/lorawan.docs docs/main The recommended approach is using docker to serve the static site locally: serve documentation locally > docker pull squidfunk/mkdocs-material # in the folder where the `docs/main` branch lives locally: > docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material Now you can see the site running locally on http://localhost:8080 . You can change the port in the docker run command.","title":"Working locally"},{"location":"user-guide/message-flows/","text":"Message Flows DefaultLoRaDataRequestHandler:ProcessRequestAsync flowchart TB ProcessRequestAsync-->ReqVal{IsValidRequest?} ReqVal-->|Yes|PerformADR ReqVal-->|No|Done PerformADR-->DedupDrop{MultiGW & Drop?} DedupDrop-->|Yes|Done DedupDrop-->|No|ReqConf{Requires confirmation?} ReqConf-->|No|HasValidFctUp{Has valid fcnt down?} ReqConf-->|Yes|HasFctDown HasFctDown-->|No|Done HasFctDown-->|Yes|HasValidFctUp{Has valid fcnt up?} HasValidFctUp-->decryptPayload[decrypt payload] decryptPayload-->IsMacAnswer{Is Mac answer?} IsMacAnswer-->|Yes|ValidFctDwn{Has valid fct down?} ValidFctDwn-->|No|Done ValidFctDwn-->|Yes|CheckSendDeviceEvt IsMacAnswer-->|No|DecodePayload DecodePayload-->C2DMsg{Has C2D msg?} C2DMsg-->|Yes|CheckSameDevice{Is for same device?} CheckSameDevice-->|Yes|ValidFctDwn2{Has valid fcnt down?} ValidFctDwn2-->|Yes|CheckSendDeviceEvt ValidFctDwn2-->|No|C2DAbandonAsync C2DAbandonAsync-->CheckSendDeviceEvt CheckSameDevice-->|No|SendC2DClassC SendC2DClassC-->CheckSendDeviceEvt C2DMsg-->|No|CheckSendDeviceEvt{Should send event upstream?} CheckSendDeviceEvt-->|Yes|SendDeviceEventAsync SendDeviceEventAsync-->ValidateTime{Still time for Rx Wnd?} CheckSendDeviceEvt-->|No|ValidateTime ValidateTime-->|No|Done ValidateTime-->|Yes|ConfirmDirect{Confirmation and no downlink or not enough time?} ConfirmDirect-->|Yes|SendDownlinkMsg ConfirmDirect-->|No|ifC2DFromDecoder{C2D msg from decoder?} ifC2DFromDecoder-->|Yes|SendDownlinkMsg ifC2DFromDecoder-->|No|fetchC2D fetchC2D-->RequiresConfirmation{Requires confirmation?} RequiresConfirmation-->|Yes|check2ndC2DTime{Enough time for 2nd C2D msg?} RequiresConfirmation-->|No|ValidFctDwn3{Has valid fcnt down?} ValidFctDwn3-->|Yes|check2ndC2DTime ValidFctDwn3-->|No|Done check2ndC2DTime-->|Yes|CheckAdditionalMessages CheckAdditionalMessages-->additionalC2DMsg{Has more messages?} additionalC2DMsg-->|Yes|setFpending[set fpending] additionalC2DMsg-->|No|SendDownlinkMsg setFpending-->SendDownlinkMsg check2ndC2DTime-->|No|SendDownlinkMsg SendDownlinkMsg-->Done(Done) Incoming message - device not cached sequenceDiagram autonumber MessageDispatcher->>LoRaDeviceRegistry: GetLoRaRequestQueue LoRaDeviceRegistry->>DeviceLoaderSynchronizer: ctor DeviceLoaderSynchronizer->>DeviceLoaderSynchronizer: Load LoRaDeviceRegistry->>MessageDispatcher: DeviceLoaderSynchronizer MessageDispatcher->>DeviceLoaderSynchronizer: Queue DeviceLoaderSynchronizer->>API: SearchByDevAddrAsync DeviceLoaderSynchronizer->>DeviceLoaderSynchronizer: CreateDevicesAsync loop For each Device DeviceLoaderSynchronizer->>LoRaDeviceFactory: Create LoRaDeviceFactory->>LoRaDeviceFactory: CreateDeviceClient DeviceLoaderSynchronizer->>LoRaDevice: InitializeAsync LoRaDevice->>LoRaDeviceClient: GetTwinAsync end DeviceLoaderSynchronizer->>DeviceLoaderSynchronizer: DispatchQueuedItems DeviceLoaderSynchronizer->>LoRaDevice: Queue LoRaDevice->>DefaultLoRaDataRequestHandler: ProcessRequestAsync The message dispatcher requests the ILoRaDeviceRequestQueue from the LoRaDeviceRegistry where the LoRaRequest can be sent to. The LoRaDeviceRegistry maintains an in memory cache per DevAddr and checks, if it has a cache and if it contains a valid device matching the NwkSKey . If it does not, the LoRaDeviceRegistry initializes a DeviceLoaderSynchronizer as ILoRaDeviceRequestQueue , and adds it to its cache under the prefix devloader . The DeviceLoaderSynchronizer ctor does trigger an async initialization Load of the devices matching the DevAddr is triggered The MessageDispatcher receives the DeviceLoaderSynchronizer The original LoRaRequest is put onto the queue where it will wait for the device to be loaded. The SearchByDevAddrAsync is calling the function and tries to get a list for that particular DevAddr . The result is a list of IoTHubDeviceInfo which contains everything required to connect the device to IoT Hub as well as the NwkSKey . The DeviceLoaderSynchronizer iterates over the result and asks for each of the result item to be materialized into a LoRaDevice . The LoRaDeviceFactory creates a LoRaDevice from the IoTHubDeviceInfo The LoRaDeviceFactory also maintains the connections per device to IoT Hub. It does that through the LoRaDeviceClientConnectionManager where LoRaDeviceClient are registered per DevEUI . Each device is initialized to get ready for processing messages The initialization is triggering the load of the twins through the LoRaDeviceClient Once the device is initialized, the messages for the device are dispatched The dispatch is putting them on the LoRaDevice Queue The LoRaDevice will process the messages in sequence to avoid contention on the device connection and delegate the processing to the ILoRaDataRequestHandler . Observations If the DevAddr does not match any of our registered devices, we keep the DeviceLoaderSynchronizer in cache for 30s (which is designed to ensure that pending requests that were already on the queue, can be processed), then it's evicted. Subsequent messages after those 30s with the same DevAddr will keep going back to the functions API. Given the fact that a device could be registered between messages, I don't see a way to avoid that except if we are willing to accept a longer period until we recognize a device. In that case we could register a 'drop' queue for the DevAddr that will be evicted after a longer time. Incoming message - device cached sequenceDiagram autonumber MessageDispatcher->>LoRaDeviceRegistry: GetLoRaRequestQueue alt in cache but not our device LoRaDeviceRegistry->>MessageDispatcher:ExternalGatewayLoRaRequestQueue:ctor else LoRaDeviceRegistry->>MessageDispatcher:cached LoRaDevice end MessageDispatcher->>LoRaDevice: Queue LoRaDevice->>DefaultLoRaDataRequestHandler: ProcessRequestAsync The message dispatcher requests the ILoRaDeviceRequestQueue from the LoRaDeviceRegistry If the device was in cache, but does not belong to our gateway, we return a ExternalGatewayLoRaRequestQueue . That queue is basically dropping any messages that are sent to it. If the device was found in the cache we return that to the MessageDispatcher . The request is put onto the LoRaDevice 's queue. The LoRaDevice will process the messages in sequence to avoid contention on the device connection and delegate the processing to the ILoRaDataRequestHandler . Join Request - OTAA sequenceDiagram autonumber MessageDispatcher->>JoinRequestMessageHandler: DispatchRequest JoinRequestMessageHandler->>JoinRequestMessageHandler: ProcessJoinRequestAsync JoinRequestMessageHandler->>LoRaOperationTimeWatcher: ctor JoinRequestMessageHandler->>LoRaDeviceRegistry: GetDeviceForJoinRequestAsync LoRaDeviceRegistry->>API: SearchAndLockForJoinAsync LoRaDeviceRegistry->>JoinDeviceLoader: ctor activate LoRaDevice par JoinDeviceLoader->>JoinDeviceLoader:LoadAsync JoinDeviceLoader->>ILoRaDeviceFactory: Create ILoRaDeviceFactory-->>JoinDeviceLoader: LoRaDevice JoinDeviceLoader->>LoRaDevice: InitializeAsync LoRaDevice->>ILoRaDeviceClient: GetTwinAsync and LoRaDeviceRegistry->>JoinDeviceLoader: WaitCompleteAsync end JoinDeviceLoader-->>LoRaDeviceRegistry: LoRaDevice LoRaDeviceRegistry-->>JoinRequestMessageHandler: LoRaDevice JoinRequestMessageHandler-->>JoinRequestMessageHandler: Validation JoinRequestMessageHandler->>OTAAKeysGenerator: CalculateKey JoinRequestMessageHandler->>LoRaOperationTimeWatcher: InTimeForJoinAccept JoinRequestMessageHandler->>LoRaDevice: UpdateAfterJoinAsync deactivate LoRaDevice The MessageDispatcher delegates the handling of the join request to the JoinRequestMessageHandler The JoinRequestMessageHandler is executing ProcessJoinRequestAsync and extracts: DevEUI, AppEUI and DevNonce from the join request. A LoRaOperationTimeWatcher is created to monitor the elapsed time for the join request. The LoRaDeviceRegistry is queried for the device matching the join request. The LoRaDeviceRegistry is asking the functions API to lookup the device using the DevEUI, AppEUI and the DevNonce. Also the Gateway Id is sent to allow locking the join request. see the GetDevice flow Q: why do we send the AppEUI ? It looks like that's not used for the OTAA join? LoRaDeviceRegistry creates a new JoinDeviceLoader (unless the loader is still in the cache - valid for 30min) passing in the IoTHubDeviceInfo . The ctor of the JoinDeviceLoader starts a thread executing LoadAsync A new LoRaDevice is created through the factory from the IoTHubDeviceInfo LoRaDevice is returned. The LoRaDevice is initialized. Twins are loaded through the ILoRaDeviceClient (keys were fetched from the API). JoinDeviceLoader is waiting for completion of the device load process The LoRaDevice is returned to the LoRaDeviceRegistry The LoRaDevice is returned to the JoinRequestMessageHandler Validation of the join request is performed (CheckMic, DevNonce, GatewayID) Keys are generated Validate that we can confirm the join to the device and are within Join_accept_delay2 for the current region. Writing DevAddr , NwkSKey , AppSKey , AppNonce , DevNonce , NetID , Region , PreferredGatewayID If we are still in time for a valid receive window, a JoinAccept will be sent to the device after calculating the DR and Frequency. Function GetDevice - OTAA sequenceDiagram autonumber LNS->>DeviceGetter:GetDevice DeviceGetter->>DeviceGetter:TryGetJoinInfoAndValidateAsync DeviceGetter->>Redis:GetObject - JoinInfo alt JoinInfo not in cache DeviceGetter->>RegistryManager: GetDeviceAsync DeviceGetter->>RegistryManager: GetTwinAsync DeviceGetter->>Redis: ObjectSet end alt if not our device DeviceGetter-->>LNS: JoinRefused end DeviceGetter->>Redis:StringSet Note over DeviceGetter,Redis: Only if it does not exist, valid: 5min alt if it did exist DeviceGetter-->>LNS: JoinRefused else DeviceGetter->>DeviceCache: TryToAcquireLock Note over DeviceGetter,DeviceCache: This tries to aquire a lock on the DevEUI alt if lock acquired DeviceGetter->>DeviceCache: KeyDelete Note over DeviceGetter,DeviceCache: Delete DevEUI key from Redis else DeviceGetter->>DeviceGetter: log warning end DeviceGetter->>LNS: IoTHubDeviceInfo end The LNS requests the device for a join request The DeviceGetter calls TryGetJoinInfoAndValidateAsync Try to get the JoinInfo (containing the primary key and the desired gateway id for the device) from Redis. If the device was not in the cache, we use the IoT Hub RegistryManager to fetch the Device If the device exists, we fetch the twins and get the Desired GatewayId. The JoinInfo is stored in Redis for 60min We validate that if there is a desired gateway, the gateway processing the join request, is the desired gateway. If not, a BadRequest is returned to the LNS indicating the join failure. We try to set the DevEUI:Nonce value in Redis cache to ensure, only 1 Gateway is processing the join request If we did not win the race, the Gateway receives a BadRequest response If we were successful we create a IoTHubDeviceInfo and try to acquire a lock on the DevEUI If we did get the lock, we delete the DevEUI key. If not, we print out a warning We return the IoTHubDeviceInfo","title":"Message Flows"},{"location":"user-guide/message-flows/#message-flows","text":"","title":"Message Flows"},{"location":"user-guide/message-flows/#defaultloradatarequesthandlerprocessrequestasync","text":"flowchart TB ProcessRequestAsync-->ReqVal{IsValidRequest?} ReqVal-->|Yes|PerformADR ReqVal-->|No|Done PerformADR-->DedupDrop{MultiGW & Drop?} DedupDrop-->|Yes|Done DedupDrop-->|No|ReqConf{Requires confirmation?} ReqConf-->|No|HasValidFctUp{Has valid fcnt down?} ReqConf-->|Yes|HasFctDown HasFctDown-->|No|Done HasFctDown-->|Yes|HasValidFctUp{Has valid fcnt up?} HasValidFctUp-->decryptPayload[decrypt payload] decryptPayload-->IsMacAnswer{Is Mac answer?} IsMacAnswer-->|Yes|ValidFctDwn{Has valid fct down?} ValidFctDwn-->|No|Done ValidFctDwn-->|Yes|CheckSendDeviceEvt IsMacAnswer-->|No|DecodePayload DecodePayload-->C2DMsg{Has C2D msg?} C2DMsg-->|Yes|CheckSameDevice{Is for same device?} CheckSameDevice-->|Yes|ValidFctDwn2{Has valid fcnt down?} ValidFctDwn2-->|Yes|CheckSendDeviceEvt ValidFctDwn2-->|No|C2DAbandonAsync C2DAbandonAsync-->CheckSendDeviceEvt CheckSameDevice-->|No|SendC2DClassC SendC2DClassC-->CheckSendDeviceEvt C2DMsg-->|No|CheckSendDeviceEvt{Should send event upstream?} CheckSendDeviceEvt-->|Yes|SendDeviceEventAsync SendDeviceEventAsync-->ValidateTime{Still time for Rx Wnd?} CheckSendDeviceEvt-->|No|ValidateTime ValidateTime-->|No|Done ValidateTime-->|Yes|ConfirmDirect{Confirmation and no downlink or not enough time?} ConfirmDirect-->|Yes|SendDownlinkMsg ConfirmDirect-->|No|ifC2DFromDecoder{C2D msg from decoder?} ifC2DFromDecoder-->|Yes|SendDownlinkMsg ifC2DFromDecoder-->|No|fetchC2D fetchC2D-->RequiresConfirmation{Requires confirmation?} RequiresConfirmation-->|Yes|check2ndC2DTime{Enough time for 2nd C2D msg?} RequiresConfirmation-->|No|ValidFctDwn3{Has valid fcnt down?} ValidFctDwn3-->|Yes|check2ndC2DTime ValidFctDwn3-->|No|Done check2ndC2DTime-->|Yes|CheckAdditionalMessages CheckAdditionalMessages-->additionalC2DMsg{Has more messages?} additionalC2DMsg-->|Yes|setFpending[set fpending] additionalC2DMsg-->|No|SendDownlinkMsg setFpending-->SendDownlinkMsg check2ndC2DTime-->|No|SendDownlinkMsg SendDownlinkMsg-->Done(Done)","title":"DefaultLoRaDataRequestHandler:ProcessRequestAsync"},{"location":"user-guide/message-flows/#incoming-message-device-not-cached","text":"sequenceDiagram autonumber MessageDispatcher->>LoRaDeviceRegistry: GetLoRaRequestQueue LoRaDeviceRegistry->>DeviceLoaderSynchronizer: ctor DeviceLoaderSynchronizer->>DeviceLoaderSynchronizer: Load LoRaDeviceRegistry->>MessageDispatcher: DeviceLoaderSynchronizer MessageDispatcher->>DeviceLoaderSynchronizer: Queue DeviceLoaderSynchronizer->>API: SearchByDevAddrAsync DeviceLoaderSynchronizer->>DeviceLoaderSynchronizer: CreateDevicesAsync loop For each Device DeviceLoaderSynchronizer->>LoRaDeviceFactory: Create LoRaDeviceFactory->>LoRaDeviceFactory: CreateDeviceClient DeviceLoaderSynchronizer->>LoRaDevice: InitializeAsync LoRaDevice->>LoRaDeviceClient: GetTwinAsync end DeviceLoaderSynchronizer->>DeviceLoaderSynchronizer: DispatchQueuedItems DeviceLoaderSynchronizer->>LoRaDevice: Queue LoRaDevice->>DefaultLoRaDataRequestHandler: ProcessRequestAsync The message dispatcher requests the ILoRaDeviceRequestQueue from the LoRaDeviceRegistry where the LoRaRequest can be sent to. The LoRaDeviceRegistry maintains an in memory cache per DevAddr and checks, if it has a cache and if it contains a valid device matching the NwkSKey . If it does not, the LoRaDeviceRegistry initializes a DeviceLoaderSynchronizer as ILoRaDeviceRequestQueue , and adds it to its cache under the prefix devloader . The DeviceLoaderSynchronizer ctor does trigger an async initialization Load of the devices matching the DevAddr is triggered The MessageDispatcher receives the DeviceLoaderSynchronizer The original LoRaRequest is put onto the queue where it will wait for the device to be loaded. The SearchByDevAddrAsync is calling the function and tries to get a list for that particular DevAddr . The result is a list of IoTHubDeviceInfo which contains everything required to connect the device to IoT Hub as well as the NwkSKey . The DeviceLoaderSynchronizer iterates over the result and asks for each of the result item to be materialized into a LoRaDevice . The LoRaDeviceFactory creates a LoRaDevice from the IoTHubDeviceInfo The LoRaDeviceFactory also maintains the connections per device to IoT Hub. It does that through the LoRaDeviceClientConnectionManager where LoRaDeviceClient are registered per DevEUI . Each device is initialized to get ready for processing messages The initialization is triggering the load of the twins through the LoRaDeviceClient Once the device is initialized, the messages for the device are dispatched The dispatch is putting them on the LoRaDevice Queue The LoRaDevice will process the messages in sequence to avoid contention on the device connection and delegate the processing to the ILoRaDataRequestHandler .","title":"Incoming message - device not cached"},{"location":"user-guide/message-flows/#observations","text":"If the DevAddr does not match any of our registered devices, we keep the DeviceLoaderSynchronizer in cache for 30s (which is designed to ensure that pending requests that were already on the queue, can be processed), then it's evicted. Subsequent messages after those 30s with the same DevAddr will keep going back to the functions API. Given the fact that a device could be registered between messages, I don't see a way to avoid that except if we are willing to accept a longer period until we recognize a device. In that case we could register a 'drop' queue for the DevAddr that will be evicted after a longer time.","title":"Observations"},{"location":"user-guide/message-flows/#incoming-message-device-cached","text":"sequenceDiagram autonumber MessageDispatcher->>LoRaDeviceRegistry: GetLoRaRequestQueue alt in cache but not our device LoRaDeviceRegistry->>MessageDispatcher:ExternalGatewayLoRaRequestQueue:ctor else LoRaDeviceRegistry->>MessageDispatcher:cached LoRaDevice end MessageDispatcher->>LoRaDevice: Queue LoRaDevice->>DefaultLoRaDataRequestHandler: ProcessRequestAsync The message dispatcher requests the ILoRaDeviceRequestQueue from the LoRaDeviceRegistry If the device was in cache, but does not belong to our gateway, we return a ExternalGatewayLoRaRequestQueue . That queue is basically dropping any messages that are sent to it. If the device was found in the cache we return that to the MessageDispatcher . The request is put onto the LoRaDevice 's queue. The LoRaDevice will process the messages in sequence to avoid contention on the device connection and delegate the processing to the ILoRaDataRequestHandler .","title":"Incoming message - device cached"},{"location":"user-guide/message-flows/#join-request-otaa","text":"sequenceDiagram autonumber MessageDispatcher->>JoinRequestMessageHandler: DispatchRequest JoinRequestMessageHandler->>JoinRequestMessageHandler: ProcessJoinRequestAsync JoinRequestMessageHandler->>LoRaOperationTimeWatcher: ctor JoinRequestMessageHandler->>LoRaDeviceRegistry: GetDeviceForJoinRequestAsync LoRaDeviceRegistry->>API: SearchAndLockForJoinAsync LoRaDeviceRegistry->>JoinDeviceLoader: ctor activate LoRaDevice par JoinDeviceLoader->>JoinDeviceLoader:LoadAsync JoinDeviceLoader->>ILoRaDeviceFactory: Create ILoRaDeviceFactory-->>JoinDeviceLoader: LoRaDevice JoinDeviceLoader->>LoRaDevice: InitializeAsync LoRaDevice->>ILoRaDeviceClient: GetTwinAsync and LoRaDeviceRegistry->>JoinDeviceLoader: WaitCompleteAsync end JoinDeviceLoader-->>LoRaDeviceRegistry: LoRaDevice LoRaDeviceRegistry-->>JoinRequestMessageHandler: LoRaDevice JoinRequestMessageHandler-->>JoinRequestMessageHandler: Validation JoinRequestMessageHandler->>OTAAKeysGenerator: CalculateKey JoinRequestMessageHandler->>LoRaOperationTimeWatcher: InTimeForJoinAccept JoinRequestMessageHandler->>LoRaDevice: UpdateAfterJoinAsync deactivate LoRaDevice The MessageDispatcher delegates the handling of the join request to the JoinRequestMessageHandler The JoinRequestMessageHandler is executing ProcessJoinRequestAsync and extracts: DevEUI, AppEUI and DevNonce from the join request. A LoRaOperationTimeWatcher is created to monitor the elapsed time for the join request. The LoRaDeviceRegistry is queried for the device matching the join request. The LoRaDeviceRegistry is asking the functions API to lookup the device using the DevEUI, AppEUI and the DevNonce. Also the Gateway Id is sent to allow locking the join request. see the GetDevice flow Q: why do we send the AppEUI ? It looks like that's not used for the OTAA join? LoRaDeviceRegistry creates a new JoinDeviceLoader (unless the loader is still in the cache - valid for 30min) passing in the IoTHubDeviceInfo . The ctor of the JoinDeviceLoader starts a thread executing LoadAsync A new LoRaDevice is created through the factory from the IoTHubDeviceInfo LoRaDevice is returned. The LoRaDevice is initialized. Twins are loaded through the ILoRaDeviceClient (keys were fetched from the API). JoinDeviceLoader is waiting for completion of the device load process The LoRaDevice is returned to the LoRaDeviceRegistry The LoRaDevice is returned to the JoinRequestMessageHandler Validation of the join request is performed (CheckMic, DevNonce, GatewayID) Keys are generated Validate that we can confirm the join to the device and are within Join_accept_delay2 for the current region. Writing DevAddr , NwkSKey , AppSKey , AppNonce , DevNonce , NetID , Region , PreferredGatewayID If we are still in time for a valid receive window, a JoinAccept will be sent to the device after calculating the DR and Frequency.","title":"Join Request - OTAA"},{"location":"user-guide/message-flows/#function-getdevice-otaa","text":"sequenceDiagram autonumber LNS->>DeviceGetter:GetDevice DeviceGetter->>DeviceGetter:TryGetJoinInfoAndValidateAsync DeviceGetter->>Redis:GetObject - JoinInfo alt JoinInfo not in cache DeviceGetter->>RegistryManager: GetDeviceAsync DeviceGetter->>RegistryManager: GetTwinAsync DeviceGetter->>Redis: ObjectSet end alt if not our device DeviceGetter-->>LNS: JoinRefused end DeviceGetter->>Redis:StringSet Note over DeviceGetter,Redis: Only if it does not exist, valid: 5min alt if it did exist DeviceGetter-->>LNS: JoinRefused else DeviceGetter->>DeviceCache: TryToAcquireLock Note over DeviceGetter,DeviceCache: This tries to aquire a lock on the DevEUI alt if lock acquired DeviceGetter->>DeviceCache: KeyDelete Note over DeviceGetter,DeviceCache: Delete DevEUI key from Redis else DeviceGetter->>DeviceGetter: log warning end DeviceGetter->>LNS: IoTHubDeviceInfo end The LNS requests the device for a join request The DeviceGetter calls TryGetJoinInfoAndValidateAsync Try to get the JoinInfo (containing the primary key and the desired gateway id for the device) from Redis. If the device was not in the cache, we use the IoT Hub RegistryManager to fetch the Device If the device exists, we fetch the twins and get the Desired GatewayId. The JoinInfo is stored in Redis for 60min We validate that if there is a desired gateway, the gateway processing the join request, is the desired gateway. If not, a BadRequest is returned to the LNS indicating the join failure. We try to set the DevEUI:Nonce value in Redis cache to ensure, only 1 Gateway is processing the join request If we did not win the race, the Gateway receives a BadRequest response If we were successful we create a IoTHubDeviceInfo and try to acquire a lock on the DevEUI If we did get the lock, we delete the DevEUI key. If not, we print out a warning We return the IoTHubDeviceInfo","title":"Function GetDevice - OTAA"},{"location":"user-guide/partner/","text":"Device Manufacturer Guidance We have developed the LoRaWAN starter kit agnostic of a device manufacturer implementation and focussed on the specifics on underlying architectures (arm, x86). However, we understand that device manufacturers can have specific requirements to ensure the LoRa packets are processed and decoded correctly. In this section, we provide guidance for the following: Gateway Manufacturers : Allow a gateway to be compatible with our kit. Gateway manufacturers will test / make our Edge Hub modules work on their gateway. LoRA Sensor Manufacturers : These manufacturers will develop a custom decoder using our decoding framework for their sensors. Please choose from a section that relates to your requirements. Device Gateway Manufacturer Guidance The LoRaWAN starter kit currently is tested on many popular gateways, we run some of those as part of daily CI/CD pipeline to test integrity and performance of our codebase. However, we cannot test each and every gateway out there and hence we have created a process for device manufacturer to support their gateways and get them highlighted in this repo. Instructions If you would like to test gateway compatibility with out starter kit and also get it highlighted on our GitHub page. To test gateway compatibility, please follow these steps: Go through the Developer Guidance to clone the repo and make sure everything works in your local dev environment. Make sure everything works with an Azure subscription with Standard Pricing SKU's, for example we do not support the Free Azure IoT Hub SKU. Ensure that the gateway specification meet the minimal hardware configuration required for Azure IoT Edge and a container framework like Docker, Moby to run. We recommend at the minimum of 1 GB RAM, rPi based boards and similar configuration devices will be a good candidate for our starter kit. If the gateway requires a specific LoRa Basics\u2122 Station not provided by our kit (we leverage an implementation of the LoRa Basics\u2122 Station). Create the appropriate code for the LoRa Basics\u2122 Station and link to our repo. Run the tests on the Gateway (must be a real device) to connect to a LoRa end node and receive and send packets. Once you have tested the framework and have all things running, open an issue on the repo and we will invite you to add a page for your gateway on our repo. The page can include details about your gateway and any specific instructions to make your gateway running with LoRaWAN starter kit. This approach provides us with validation that things work on the gateway and also allows others using the same Gateway to leverage the learnings. Device Node (sensor) Manufacturer Guidance If you are a LoRa Node/Sensor manufacturer that leverages specific decoding scheme for the LoRa packets, we have provision for you to run those devices using our decoding framework. Instructions Follow these steps to onboard your device with a custom decoder: Go through the Developer Guidance to clone the repo and make sure everything works in your local dev environment. Make sure everything works with an Azure subscription with Standard Pricing SKU's, for example we do not support the Free Azure IoT Hub SKU. We have provided a sample reference implementation of a decoder, please refer to this as a template and leverage the instructions to create implementation of your customer decoder. The Sample code can also contain device model specific tests that when run allows for testing of the gateway. Since we are .NET Core and C# based, the sample is based on the .NET technology stack, however you can create your decoders in your preferred languages by implementing similar interfaces. If you have a specific language or platform to be supported, submit an issue to let us know.","title":"Device Manufacturer Guidance"},{"location":"user-guide/partner/#device-manufacturer-guidance","text":"We have developed the LoRaWAN starter kit agnostic of a device manufacturer implementation and focussed on the specifics on underlying architectures (arm, x86). However, we understand that device manufacturers can have specific requirements to ensure the LoRa packets are processed and decoded correctly. In this section, we provide guidance for the following: Gateway Manufacturers : Allow a gateway to be compatible with our kit. Gateway manufacturers will test / make our Edge Hub modules work on their gateway. LoRA Sensor Manufacturers : These manufacturers will develop a custom decoder using our decoding framework for their sensors. Please choose from a section that relates to your requirements.","title":"Device Manufacturer Guidance"},{"location":"user-guide/partner/#device-gateway-manufacturer-guidance","text":"The LoRaWAN starter kit currently is tested on many popular gateways, we run some of those as part of daily CI/CD pipeline to test integrity and performance of our codebase. However, we cannot test each and every gateway out there and hence we have created a process for device manufacturer to support their gateways and get them highlighted in this repo.","title":"Device Gateway Manufacturer Guidance"},{"location":"user-guide/partner/#instructions","text":"If you would like to test gateway compatibility with out starter kit and also get it highlighted on our GitHub page. To test gateway compatibility, please follow these steps: Go through the Developer Guidance to clone the repo and make sure everything works in your local dev environment. Make sure everything works with an Azure subscription with Standard Pricing SKU's, for example we do not support the Free Azure IoT Hub SKU. Ensure that the gateway specification meet the minimal hardware configuration required for Azure IoT Edge and a container framework like Docker, Moby to run. We recommend at the minimum of 1 GB RAM, rPi based boards and similar configuration devices will be a good candidate for our starter kit. If the gateway requires a specific LoRa Basics\u2122 Station not provided by our kit (we leverage an implementation of the LoRa Basics\u2122 Station). Create the appropriate code for the LoRa Basics\u2122 Station and link to our repo. Run the tests on the Gateway (must be a real device) to connect to a LoRa end node and receive and send packets. Once you have tested the framework and have all things running, open an issue on the repo and we will invite you to add a page for your gateway on our repo. The page can include details about your gateway and any specific instructions to make your gateway running with LoRaWAN starter kit. This approach provides us with validation that things work on the gateway and also allows others using the same Gateway to leverage the learnings.","title":"Instructions"},{"location":"user-guide/partner/#device-node-sensor-manufacturer-guidance","text":"If you are a LoRa Node/Sensor manufacturer that leverages specific decoding scheme for the LoRa packets, we have provision for you to run those devices using our decoding framework.","title":"Device Node (sensor) Manufacturer Guidance"},{"location":"user-guide/partner/#instructions_1","text":"Follow these steps to onboard your device with a custom decoder: Go through the Developer Guidance to clone the repo and make sure everything works in your local dev environment. Make sure everything works with an Azure subscription with Standard Pricing SKU's, for example we do not support the Free Azure IoT Hub SKU. We have provided a sample reference implementation of a decoder, please refer to this as a template and leverage the instructions to create implementation of your customer decoder. The Sample code can also contain device model specific tests that when run allows for testing of the gateway. Since we are .NET Core and C# based, the sample is based on the .NET technology stack, however you can create your decoders in your preferred languages by implementing similar interfaces. If you have a specific language or platform to be supported, submit an issue to let us know.","title":"Instructions"},{"location":"user-guide/station-configuration/","text":"Basics Station configuration Following the LoRaWAN Network Server (LNS) specification, each Basics Station (LBS) will at some point invoke the discovery endpoint on a LNS. Subsequently, it will establish a data connection on the data endpoint to receive its setup information. To ensure that the LBS is able to receive the setup information, you will need to add the LBS configuration (in LNS protocol specification called: \" router_config \") to IoT Hub. An LBS that does not have its configuration stored in IoT Hub will not be able to connect to the LNS. In the following we describe how to register an LBS in IoT Hub and how to store its configuration. Create an IoT Hub device that has a name equal to the LBS EUI in hex-representation, e.g. DCA632FFFEB32FC6 . If you are running a dev kit on a Linux machine, the EUI will be retrieved from the MAC address of the eth0 interface as follows: cat /sys/class/net/eth0/address # prints the MAC Address of eth0 # Assuming aa:bb:cc:00:11:22 is the returned MAC Address # your EUI will be AABBCCFFFE001122 # Please note the insertion of the literals 'FFFE' in the middle, as per https://doc.sm.tc/station/glossary.html?highlight=mac The LBS configuration needs to be stored as a desired twin property of the newly created LBS device. Make sure to store the configuration under properties.desired.routerConfig . The configuration follows the router_config format from the LNS protocol as closely as possible. However, since device twins encode numbers as 32-bit values and given some configuration properties (such as EUIs) are 64-bit numbers, there are some minor differences. The JoinEui nested array must consist of hexadecimal-encoded strings. The property should look similar to: \"JoinEui\": [[\"DCA632FFFEB32FC5\",\"DCA632FFFEB32FC7\"]] A full configuration example might look like this, relative to the desired twin property path properties.desired : EU863 Example Configuration ```json { \"routerConfig\": { \"NetID\": [1], \"JoinEui\": [[\"DCA632FFFEB32FC5\", \"DCA632FFFEB32FC7\"]], \"region\": \"EU863\", \"hwspec\": \"sx1301/1\", \"freq_range\": [863000000, 870000000], \"DRs\": [ [11, 125, 0], [10, 125, 0], [9, 125, 0], [8, 125, 0], [7, 125, 0], [7, 250, 0] ], \"sx1301_conf\": [ { \"radio_0\": { \"enable\": true, \"freq\": 867500000 }, \"radio_1\": { \"enable\": true, \"freq\": 868500000 }, \"chan_FSK\": { \"enable\": true, \"radio\": 1, \"if\": 300000 }, \"chan_Lora_std\": { \"enable\": true, \"radio\": 1, \"if\": -200000, \"bandwidth\": 250000, \"spread_factor\": 7 }, \"chan_multiSF_0\": { \"enable\": true, \"radio\": 1, \"if\": -400000 }, \"chan_multiSF_1\": { \"enable\": true, \"radio\": 1, \"if\": -200000 }, \"chan_multiSF_2\": { \"enable\": true, \"radio\": 1, \"if\": 0 }, \"chan_multiSF_3\": { \"enable\": true, \"radio\": 0, \"if\": -400000 }, \"chan_multiSF_4\": { \"enable\": true, \"radio\": 0, \"if\": -200000 }, \"chan_multiSF_5\": { \"enable\": true, \"radio\": 0, \"if\": 0 }, \"chan_multiSF_6\": { \"enable\": true, \"radio\": 0, \"if\": 200000 }, \"chan_multiSF_7\": { \"enable\": true, \"radio\": 0, \"if\": 400000 } } ], \"nocca\": true, \"nodc\": true, \"nodwell\": true } } ``` US902 Example Configuration ```json { \"routerConfig\": { \"NetID\": [1], \"JoinEui\": [[\"DCA632FFFEB32FC5\", \"DCA632FFFEB32FC7\"]], \"region\": \"US902\", \"hwspec\": \"sx1301/1\", \"freq_range\": [902000000, 928000000], \"DRs\": [ [10, 125, 0], [9, 125, 0], [8, 125, 0], [7, 125, 0], [8, 500, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [12, 500, 1], [11, 500, 1], [10, 500, 1], [9, 500, 1], [8, 500, 1], [8, 500, 1] ], \"sx1301_conf\": [ { \"radio_0\": { \"enable\": true, \"freq\": 902700000 }, \"radio_1\": { \"enable\": true, \"freq\": 903400000 }, \"chan_FSK\": { \"enable\": true, \"radio\": 1, \"if\": 300000 }, \"chan_Lora_std\": { \"enable\": true, \"radio\": 0, \"if\": 300000, \"bandwidth\": 500000, \"spread_factor\": 8 }, \"chan_multiSF_0\": { \"enable\": true, \"radio\": 0, \"if\": -400000 }, \"chan_multiSF_1\": { \"enable\": true, \"radio\": 0, \"if\": -200000 }, \"chan_multiSF_2\": { \"enable\": true, \"radio\": 0, \"if\": 0 }, \"chan_multiSF_3\": { \"enable\": true, \"radio\": 0, \"if\": 200000 }, \"chan_multiSF_4\": { \"enable\": true, \"radio\": 1, \"if\": -300000 }, \"chan_multiSF_5\": { \"enable\": true, \"radio\": 1, \"if\": -100000 }, \"chan_multiSF_6\": { \"enable\": true, \"radio\": 1, \"if\": 100000 }, \"chan_multiSF_7\": { \"enable\": true, \"radio\": 1, \"if\": 300000 } } ], \"nocca\": true, \"nodc\": true, \"nodwell\": true } } ``` A more thorough description of sx1301_conf can be found at The LNS Protocol specification. By saving the configuration per LBS in its device twin, the LBS will be able to successfully connect to the LNS and it can start sending frames.","title":"Basics Station configuration"},{"location":"user-guide/station-configuration/#basics-station-configuration","text":"Following the LoRaWAN Network Server (LNS) specification, each Basics Station (LBS) will at some point invoke the discovery endpoint on a LNS. Subsequently, it will establish a data connection on the data endpoint to receive its setup information. To ensure that the LBS is able to receive the setup information, you will need to add the LBS configuration (in LNS protocol specification called: \" router_config \") to IoT Hub. An LBS that does not have its configuration stored in IoT Hub will not be able to connect to the LNS. In the following we describe how to register an LBS in IoT Hub and how to store its configuration. Create an IoT Hub device that has a name equal to the LBS EUI in hex-representation, e.g. DCA632FFFEB32FC6 . If you are running a dev kit on a Linux machine, the EUI will be retrieved from the MAC address of the eth0 interface as follows: cat /sys/class/net/eth0/address # prints the MAC Address of eth0 # Assuming aa:bb:cc:00:11:22 is the returned MAC Address # your EUI will be AABBCCFFFE001122 # Please note the insertion of the literals 'FFFE' in the middle, as per https://doc.sm.tc/station/glossary.html?highlight=mac The LBS configuration needs to be stored as a desired twin property of the newly created LBS device. Make sure to store the configuration under properties.desired.routerConfig . The configuration follows the router_config format from the LNS protocol as closely as possible. However, since device twins encode numbers as 32-bit values and given some configuration properties (such as EUIs) are 64-bit numbers, there are some minor differences. The JoinEui nested array must consist of hexadecimal-encoded strings. The property should look similar to: \"JoinEui\": [[\"DCA632FFFEB32FC5\",\"DCA632FFFEB32FC7\"]] A full configuration example might look like this, relative to the desired twin property path properties.desired : EU863 Example Configuration ```json { \"routerConfig\": { \"NetID\": [1], \"JoinEui\": [[\"DCA632FFFEB32FC5\", \"DCA632FFFEB32FC7\"]], \"region\": \"EU863\", \"hwspec\": \"sx1301/1\", \"freq_range\": [863000000, 870000000], \"DRs\": [ [11, 125, 0], [10, 125, 0], [9, 125, 0], [8, 125, 0], [7, 125, 0], [7, 250, 0] ], \"sx1301_conf\": [ { \"radio_0\": { \"enable\": true, \"freq\": 867500000 }, \"radio_1\": { \"enable\": true, \"freq\": 868500000 }, \"chan_FSK\": { \"enable\": true, \"radio\": 1, \"if\": 300000 }, \"chan_Lora_std\": { \"enable\": true, \"radio\": 1, \"if\": -200000, \"bandwidth\": 250000, \"spread_factor\": 7 }, \"chan_multiSF_0\": { \"enable\": true, \"radio\": 1, \"if\": -400000 }, \"chan_multiSF_1\": { \"enable\": true, \"radio\": 1, \"if\": -200000 }, \"chan_multiSF_2\": { \"enable\": true, \"radio\": 1, \"if\": 0 }, \"chan_multiSF_3\": { \"enable\": true, \"radio\": 0, \"if\": -400000 }, \"chan_multiSF_4\": { \"enable\": true, \"radio\": 0, \"if\": -200000 }, \"chan_multiSF_5\": { \"enable\": true, \"radio\": 0, \"if\": 0 }, \"chan_multiSF_6\": { \"enable\": true, \"radio\": 0, \"if\": 200000 }, \"chan_multiSF_7\": { \"enable\": true, \"radio\": 0, \"if\": 400000 } } ], \"nocca\": true, \"nodc\": true, \"nodwell\": true } } ``` US902 Example Configuration ```json { \"routerConfig\": { \"NetID\": [1], \"JoinEui\": [[\"DCA632FFFEB32FC5\", \"DCA632FFFEB32FC7\"]], \"region\": \"US902\", \"hwspec\": \"sx1301/1\", \"freq_range\": [902000000, 928000000], \"DRs\": [ [10, 125, 0], [9, 125, 0], [8, 125, 0], [7, 125, 0], [8, 500, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [12, 500, 1], [11, 500, 1], [10, 500, 1], [9, 500, 1], [8, 500, 1], [8, 500, 1] ], \"sx1301_conf\": [ { \"radio_0\": { \"enable\": true, \"freq\": 902700000 }, \"radio_1\": { \"enable\": true, \"freq\": 903400000 }, \"chan_FSK\": { \"enable\": true, \"radio\": 1, \"if\": 300000 }, \"chan_Lora_std\": { \"enable\": true, \"radio\": 0, \"if\": 300000, \"bandwidth\": 500000, \"spread_factor\": 8 }, \"chan_multiSF_0\": { \"enable\": true, \"radio\": 0, \"if\": -400000 }, \"chan_multiSF_1\": { \"enable\": true, \"radio\": 0, \"if\": -200000 }, \"chan_multiSF_2\": { \"enable\": true, \"radio\": 0, \"if\": 0 }, \"chan_multiSF_3\": { \"enable\": true, \"radio\": 0, \"if\": 200000 }, \"chan_multiSF_4\": { \"enable\": true, \"radio\": 1, \"if\": -300000 }, \"chan_multiSF_5\": { \"enable\": true, \"radio\": 1, \"if\": -100000 }, \"chan_multiSF_6\": { \"enable\": true, \"radio\": 1, \"if\": 100000 }, \"chan_multiSF_7\": { \"enable\": true, \"radio\": 1, \"if\": 300000 } } ], \"nocca\": true, \"nodc\": true, \"nodwell\": true } } ``` A more thorough description of sx1301_conf can be found at The LNS Protocol specification. By saving the configuration per LBS in its device twin, the LBS will be able to successfully connect to the LNS and it can start sending frames.","title":"Basics Station configuration"},{"location":"user-guide/station-credential-management/","text":"Basics Station credentials management Starting with 'Azure IoT Edge LoRaWAN Starter Kit' v2.0.0, the LoRaWan Network Server runs a WebSocket endpoint compatible with The LNS Protocol from LoRa Basics\u2122 Station. As described in the official LoRa Basics\u2122 Station documentation - Credentials a Basics\u2122 Station client needs some credentials to establish a secure connection to LNS compatible endpoints. Server Authentication Importing certificate for server authentication in LoRaWan Network Server module LoRaWan Network Server IoT Edge module allows to import, a certificate in 'pkcs12' format (.pfx) from disk to be used for server authentication. Two environment variables need to be set for making this happen: LNS_SERVER_PFX_PATH : It's the absolute path to the .pfx certificate in the IoT Edge module filesystem (i.e.: '/var/lorastarterkit/certs/lns.pfx') LNS_SERVER_PFX_PASSWORD (optional) : needs to be set if the .pfx was exported with password Assuming the .pfx file is located in a folder on the host OS at /mnt/lora/certs, you will need to 'bind' this path to one in the IoT Edge module itself. In order to do so: Log into your Azure Portal Identify the IoT Edge Device in IoT Hub Set the 'LoRaWanNetworkSrvModule' HostConfiguration to include a binding for the folder \"Binds\" : [ \"/mnt/lora/certs/:/var/lorastarterkit/certs/\" ] Additional information on this process can be found in the documentation - Use IoT Edge device local storage from a module . Importing 'tc.trust' in bundled 'LoRaBasicsStationModule' If you are making use of the bundled 'LoRaBasicsStationModule', it's possible to import a tc.trust certificate in the module itself. The default path where the tc.trust will be searched is '/var/lorastarterkit/certs/'. As described in the previous section, it is possible to bind a folder on the host os to the one mentioned above. The default path of the tc.trust file can be overridden by using the 'TC_TRUST_PATH' environment variable (i.e.: setting it to '/var/otherfolder/my.ca' will make the module copy the my.ca file to a tc.trust in the LoRa Basics\u2122 Station working directory). Client certification Currently LoRaWan Network Server does not implement any client certificate validation.","title":"Basics Station credentials management"},{"location":"user-guide/station-credential-management/#basics-station-credentials-management","text":"Starting with 'Azure IoT Edge LoRaWAN Starter Kit' v2.0.0, the LoRaWan Network Server runs a WebSocket endpoint compatible with The LNS Protocol from LoRa Basics\u2122 Station. As described in the official LoRa Basics\u2122 Station documentation - Credentials a Basics\u2122 Station client needs some credentials to establish a secure connection to LNS compatible endpoints.","title":"Basics Station credentials management"},{"location":"user-guide/station-credential-management/#server-authentication","text":"","title":"Server Authentication"},{"location":"user-guide/station-credential-management/#importing-certificate-for-server-authentication-in-lorawan-network-server-module","text":"LoRaWan Network Server IoT Edge module allows to import, a certificate in 'pkcs12' format (.pfx) from disk to be used for server authentication. Two environment variables need to be set for making this happen: LNS_SERVER_PFX_PATH : It's the absolute path to the .pfx certificate in the IoT Edge module filesystem (i.e.: '/var/lorastarterkit/certs/lns.pfx') LNS_SERVER_PFX_PASSWORD (optional) : needs to be set if the .pfx was exported with password Assuming the .pfx file is located in a folder on the host OS at /mnt/lora/certs, you will need to 'bind' this path to one in the IoT Edge module itself. In order to do so: Log into your Azure Portal Identify the IoT Edge Device in IoT Hub Set the 'LoRaWanNetworkSrvModule' HostConfiguration to include a binding for the folder \"Binds\" : [ \"/mnt/lora/certs/:/var/lorastarterkit/certs/\" ] Additional information on this process can be found in the documentation - Use IoT Edge device local storage from a module .","title":"Importing certificate for server authentication in LoRaWan Network Server module"},{"location":"user-guide/station-credential-management/#importing-tctrust-in-bundled-lorabasicsstationmodule","text":"If you are making use of the bundled 'LoRaBasicsStationModule', it's possible to import a tc.trust certificate in the module itself. The default path where the tc.trust will be searched is '/var/lorastarterkit/certs/'. As described in the previous section, it is possible to bind a folder on the host os to the one mentioned above. The default path of the tc.trust file can be overridden by using the 'TC_TRUST_PATH' environment variable (i.e.: setting it to '/var/otherfolder/my.ca' will make the module copy the my.ca file to a tc.trust in the LoRa Basics\u2122 Station working directory).","title":"Importing 'tc.trust' in bundled 'LoRaBasicsStationModule'"},{"location":"user-guide/station-credential-management/#client-certification","text":"Currently LoRaWan Network Server does not implement any client certificate validation.","title":"Client certification"},{"location":"user-guide/station-module-configuration/","text":"Basics Station IoT Edge Module configuration parameters The following table is providing a list of configuration options, to be provided as environment variables for manual configuration of the 'LoRaBasicsStationModule': Environment variable name Description Mandatory TC_URI The URI to the LNS Server implementation Yes (i.e.: 'ws://IP_or_DNS:PORT') RESET_PIN Pin number for resetting the concentrator. It is board specific. No (if not set, module will skip the reset of the board) SPI_DEV A number identifying the location where the board should be accessed (i.e.: when X, board accessed at /dev/spidevX.0) No (defaults to 0) SPI_SPEED Useful for setting SPI max clock No (default to 8, unique alternative provided is 2) TC_TRUST_PATH The path to the tc.trust file. Refer to this file for more information No (if not set, defaulting to '/var/lorastarterkit/certs/tc.trust')","title":"Basics Station IoT Edge Module configuration parameters"},{"location":"user-guide/station-module-configuration/#basics-station-iot-edge-module-configuration-parameters","text":"The following table is providing a list of configuration options, to be provided as environment variables for manual configuration of the 'LoRaBasicsStationModule': Environment variable name Description Mandatory TC_URI The URI to the LNS Server implementation Yes (i.e.: 'ws://IP_or_DNS:PORT') RESET_PIN Pin number for resetting the concentrator. It is board specific. No (if not set, module will skip the reset of the board) SPI_DEV A number identifying the location where the board should be accessed (i.e.: when X, board accessed at /dev/spidevX.0) No (defaults to 0) SPI_SPEED Useful for setting SPI max clock No (default to 8, unique alternative provided is 2) TC_TRUST_PATH The path to the tc.trust file. Refer to this file for more information No (if not set, defaulting to '/var/lorastarterkit/certs/tc.trust')","title":"Basics Station IoT Edge Module configuration parameters"},{"location":"user-guide/upgrade/","text":"Upgrade LoRaWAN to a new version Release 1.0.7 To update from version 1.0.6, 1.0.5, 1.0.4 or 1.0.3 you can follow the below instructions. If you want to update manually from a version prior to 1.0.3, please refer to the instructions in the Release 1.0.3 section below. Update the IoT Edge security daemon when upgrading from IoT Edge 1.1 (release prior to 1.0.6) Since release 1.0.6, the starter kit uses Azure IoT Edge version 1.2 which includes major changes the the IoT Edge Security daemon. Please follow this documentation to Update IoT Edge to upgrade Azure IoT Edge to 1.2. Updating from release post 1.0.3 Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.7 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.7 On the same Set Modules page, also update your current edge version to 1.2.2 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.2.2 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.2.2 and mcr.microsoft.com/azureiotedge-agent:1.2.2. Updating the Azure Function Facade If you are upgrading from release 1.0.5, There are no changes on the Azure function therefore you can use the same bin. If you are upgrading from a previous release please follow function deployment guidance under release Release 1.0.5 . Release 1.0.6 To update from version 1.0.5, 1.0.4 or 1.0.3 you can follow the below instructions. If you want to update manually from a version prior to 1.0.3, please refer to the instructions in the Release 1.0.3 section below. Update the IoT Edge security daemon when upgrading from IoT Edge 1.1 Since release 1.0.6, the starter kit uses Azure IoT Edge version 1.2 which includes major changes the the IoT Edge Security daemon. Please follow this documentation to Update IoT Edge to upgrade Azure IoT Edge to 1.2. Updating from 1.0.5, 1.0.4 or 1.0.3 Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.6 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.6 On the same Set Modules page, also update your current edge version to 1.2.2 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.2.2 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.2.2 and mcr.microsoft.com/azureiotedge-agent:1.2.2. Updating the Azure Function Facade There are no changes on the Azure function therefore you can use the same versioning as Release 1.0.5 just below. Release 1.0.5 To update from version 1.0.4 or 1.0.3 you can follow the below instructions. If you want to update manually from a version prior to 1.0.3, please refer to the instructions in the Release 1.0.3 section below. Updating from 1.0.4 or 1.0.3 Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.5 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.5 On the same Set Modules page, also update your current edge version to 1.0.9.5 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.0.9.5 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.0.9.5 and mcr.microsoft.com/azureiotedge-agent:1.0.9.5. Updating the Azure Function Facade If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.5/function-1.0.5.zip Release 1.0.4 To update from version 1.0.3 you can follow the below instructions. If you want to update manually from a version prior to 1.0.3, please refer to the instructions in the Release 1.0.3 section below. Updating from 1.0.3 Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.4 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.4 On the same Set Modules page, also update your current edge version to 1.0.9.4 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.0.9.4 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.0.9.4 and mcr.microsoft.com/azureiotedge-agent:1.0.9.4. Updating the Azure Function Facade If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.4/function-1.0.4.zip Release 1.0.3 To update from 1.0.1 or 1.0.2 you can follow the below instructions. If you want to update manually from a version prior to 1.0.1, please refer to Updating existing installations from 1.0.0 to release 1.0.1 section below. Updating existing installations from 1.0.1 or 1.0.2 to release 1.0.3 Go to your solution's Azure IoT Hub and under IoT Edge, select each of your gateways. Select Set Modules and configure the two deployment modules LoRaWanNetworkSrvModule and LoRaWanPktFwdModule . Make sure, the following image URIs are configured: Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.3 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.3 On the same Set Modules page, also update your current edge version to 1.0.9 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.0.9 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.0.9 and mcr.microsoft.com/azureiotedge-agent:1.0.9. Updating the Azure Function Facade If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.3/function-1.0.3.zip Release 1.0.2 We recommend re-deploying your solution based on the 1.0.2 release if you have been working with a solution before version 1.0.2. To update from 1.0.1 you can follow the below instructions. If you want to update manually from a version prior to 1.0.1, please refer to Updating existing installations from 1.0.0 to release 1.0.1 section below. Updating existing installations from 1.0.1 to release 1.0.2 Go to your solution's Azure IoT Hub and under IoT Edge, select each of your gateways. Select Set Modules and configure the two deployment modules LoRaWanNetworkSrvModule and LoRaWanPktFwdModule . Make sure, the following image URIs are configured: Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.2 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.2 On the same Set Modules page, also update your current edge version to 1.0.7 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.0.7 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.0.7 and mcr.microsoft.com/azureiotedge-agent:1.0.7. Updating the Azure Function Facade If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.2/function-1.0.2.zip Release 1.0.1 We recommend re-deploying your solution based on the 1.0.1 release if you have been working with a pre-release version. If you prefer to update your existing installation, the following lists describes the required steps. Updating existing installations from 1.0.0 to release 1.0.1 Updating your gateways' IoT Edge module versions Go to your solution's Azure IoT Hub and under IoT Edge, select each of your gateways. Select Set Modules and configure the two deployment modules LoRaWanNetworkSrvModule and LoRaWanPktFwdModule . Make sure, the following image URIs are configured: Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.1 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.1 Updating the Azure Function Facade If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.1/function-1.0.1.zip Edit the Function's Application settings and make sure the FUNCTIONS_EXTENSION_VERSION App setting is set to ~2 . If during a previous upgrade you manually set it to 2.0.12342.0 , please change it back to ~2 . App Settings Name Value FUNCTIONS_EXTENSION_VERSION ~2 Make sure the IoT Hub and Redis connection strings are properly configured in the function. Updating existing installations from 0.4.0-preview to release 1.0.0 Updating the Azure Function Facade If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.0/function-1.0.0.zip Edit the Function's Application settings and change the FUNCTIONS_EXTENSION_VERSION App setting from ~2 to 2.0.12342.0 App Settings Name Value FUNCTIONS_EXTENSION_VERSION 2.0.12342.0 Make sure the IoT Hub and Redis connection strings are properly configured in the function. Updating existing installations from 0.3.0-preview to 0.4.0-preview Updating IoT Edge Runtime Containers to Version 1.0.6 We highly recommend running the latest version of the IoT Edge runtime containers on your gateway to Version 1.0.6. The way that you update the IoT Edge agent and IoT Edge hub containers depends on whether you use rolling tags (like 1.0) or specific tags (like 1.0.2) in your deployment. The process is outlined in detail here . Furthermore, make sure, the following environment variables are set for your Edge hub container: mqttSettings__enabled: false httpSettings__enabled: false TwinManagerVersion: v2 You do this by clicking \"Set Modules\" \u2192 \"Configure advanced edge runtime settings\" on your IoT Edge device in Azure IoT Hub. Make sure the DevAddr of your ABP LoRa devices starts with \"02\" : Due to addition of NetId support in this pre-relese, ABP devices created by the template prior to 0.4.0-preview (and all devices with an incompatible NetId in general) will be incompatible with the 0.4.0-preview. In this case, make sure the DevAddr of your ABP LoRa devices starts with \"02\". Updating the Azure Function Facade Re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. Make sure the IoT Hub and Redis connection strings are properly configured in the function. Updating existing installations from 0.2.0-preview to 0.3.0-preview Updating IoT Edge Runtime Containers to Version 1.0.5 We highly recommend running the latest version of the IoT Edge runtime containers on your gateway (Version 1.0.5 at the time of writing). The way that you update the IoT Edge agent and IoT Edge hub containers depends on whether you use rolling tags (like 1.0) or specific tags (like 1.0.2) in your deployment. The process is outlined in detail here . Updating the Azure Function Facade Re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. Make sure the IoT Hub and Redis connection strings are properly configured in the function.","title":"Upgrade LoRaWAN to a new version"},{"location":"user-guide/upgrade/#upgrade-lorawan-to-a-new-version","text":"","title":"Upgrade LoRaWAN to a new version"},{"location":"user-guide/upgrade/#release-107","text":"To update from version 1.0.6, 1.0.5, 1.0.4 or 1.0.3 you can follow the below instructions. If you want to update manually from a version prior to 1.0.3, please refer to the instructions in the Release 1.0.3 section below.","title":"Release 1.0.7"},{"location":"user-guide/upgrade/#update-the-iot-edge-security-daemon-when-upgrading-from-iot-edge-11-release-prior-to-106","text":"Since release 1.0.6, the starter kit uses Azure IoT Edge version 1.2 which includes major changes the the IoT Edge Security daemon. Please follow this documentation to Update IoT Edge to upgrade Azure IoT Edge to 1.2.","title":"Update the IoT Edge security daemon when upgrading from IoT Edge 1.1 (release prior to 1.0.6)"},{"location":"user-guide/upgrade/#updating-from-release-post-103","text":"Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.7 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.7 On the same Set Modules page, also update your current edge version to 1.2.2 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.2.2 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.2.2 and mcr.microsoft.com/azureiotedge-agent:1.2.2.","title":"Updating from release post 1.0.3"},{"location":"user-guide/upgrade/#updating-the-azure-function-facade","text":"If you are upgrading from release 1.0.5, There are no changes on the Azure function therefore you can use the same bin. If you are upgrading from a previous release please follow function deployment guidance under release Release 1.0.5 .","title":"Updating the Azure Function Facade"},{"location":"user-guide/upgrade/#release-106","text":"To update from version 1.0.5, 1.0.4 or 1.0.3 you can follow the below instructions. If you want to update manually from a version prior to 1.0.3, please refer to the instructions in the Release 1.0.3 section below.","title":"Release 1.0.6"},{"location":"user-guide/upgrade/#update-the-iot-edge-security-daemon-when-upgrading-from-iot-edge-11","text":"Since release 1.0.6, the starter kit uses Azure IoT Edge version 1.2 which includes major changes the the IoT Edge Security daemon. Please follow this documentation to Update IoT Edge to upgrade Azure IoT Edge to 1.2.","title":"Update the IoT Edge security daemon when upgrading from IoT Edge 1.1"},{"location":"user-guide/upgrade/#updating-from-105-104-or-103","text":"Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.6 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.6 On the same Set Modules page, also update your current edge version to 1.2.2 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.2.2 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.2.2 and mcr.microsoft.com/azureiotedge-agent:1.2.2.","title":"Updating from 1.0.5, 1.0.4 or 1.0.3"},{"location":"user-guide/upgrade/#updating-the-azure-function-facade_1","text":"There are no changes on the Azure function therefore you can use the same versioning as Release 1.0.5 just below.","title":"Updating the Azure Function Facade"},{"location":"user-guide/upgrade/#release-105","text":"To update from version 1.0.4 or 1.0.3 you can follow the below instructions. If you want to update manually from a version prior to 1.0.3, please refer to the instructions in the Release 1.0.3 section below.","title":"Release 1.0.5"},{"location":"user-guide/upgrade/#updating-from-104-or-103","text":"Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.5 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.5 On the same Set Modules page, also update your current edge version to 1.0.9.5 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.0.9.5 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.0.9.5 and mcr.microsoft.com/azureiotedge-agent:1.0.9.5.","title":"Updating from 1.0.4 or 1.0.3"},{"location":"user-guide/upgrade/#updating-the-azure-function-facade_2","text":"If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.5/function-1.0.5.zip","title":"Updating the Azure Function Facade"},{"location":"user-guide/upgrade/#release-104","text":"To update from version 1.0.3 you can follow the below instructions. If you want to update manually from a version prior to 1.0.3, please refer to the instructions in the Release 1.0.3 section below.","title":"Release 1.0.4"},{"location":"user-guide/upgrade/#updating-from-103","text":"Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.4 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.4 On the same Set Modules page, also update your current edge version to 1.0.9.4 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.0.9.4 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.0.9.4 and mcr.microsoft.com/azureiotedge-agent:1.0.9.4.","title":"Updating from 1.0.3"},{"location":"user-guide/upgrade/#updating-the-azure-function-facade_3","text":"If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.4/function-1.0.4.zip","title":"Updating the Azure Function Facade"},{"location":"user-guide/upgrade/#release-103","text":"To update from 1.0.1 or 1.0.2 you can follow the below instructions. If you want to update manually from a version prior to 1.0.1, please refer to Updating existing installations from 1.0.0 to release 1.0.1 section below.","title":"Release 1.0.3"},{"location":"user-guide/upgrade/#updating-existing-installations-from-101-or-102-to-release-103","text":"Go to your solution's Azure IoT Hub and under IoT Edge, select each of your gateways. Select Set Modules and configure the two deployment modules LoRaWanNetworkSrvModule and LoRaWanPktFwdModule . Make sure, the following image URIs are configured: Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.3 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.3 On the same Set Modules page, also update your current edge version to 1.0.9 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.0.9 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.0.9 and mcr.microsoft.com/azureiotedge-agent:1.0.9.","title":"Updating existing installations from 1.0.1 or 1.0.2 to release 1.0.3"},{"location":"user-guide/upgrade/#updating-the-azure-function-facade_4","text":"If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.3/function-1.0.3.zip","title":"Updating the Azure Function Facade"},{"location":"user-guide/upgrade/#release-102","text":"We recommend re-deploying your solution based on the 1.0.2 release if you have been working with a solution before version 1.0.2. To update from 1.0.1 you can follow the below instructions. If you want to update manually from a version prior to 1.0.1, please refer to Updating existing installations from 1.0.0 to release 1.0.1 section below.","title":"Release 1.0.2"},{"location":"user-guide/upgrade/#updating-existing-installations-from-101-to-release-102","text":"Go to your solution's Azure IoT Hub and under IoT Edge, select each of your gateways. Select Set Modules and configure the two deployment modules LoRaWanNetworkSrvModule and LoRaWanPktFwdModule . Make sure, the following image URIs are configured: Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.2 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.2 On the same Set Modules page, also update your current edge version to 1.0.7 by pressing the Configure Advanced Edge Runtime settings button. On the menu, ensure the edge hub and edge agent are using version 1.0.7 by respectively setting image name to mcr.microsoft.com/azureiotedge-hub:1.0.7 and mcr.microsoft.com/azureiotedge-agent:1.0.7.","title":"Updating existing installations from 1.0.1 to release 1.0.2"},{"location":"user-guide/upgrade/#updating-the-azure-function-facade_5","text":"If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.2/function-1.0.2.zip","title":"Updating the Azure Function Facade"},{"location":"user-guide/upgrade/#release-101","text":"We recommend re-deploying your solution based on the 1.0.1 release if you have been working with a pre-release version. If you prefer to update your existing installation, the following lists describes the required steps.","title":"Release 1.0.1"},{"location":"user-guide/upgrade/#updating-existing-installations-from-100-to-release-101","text":"","title":"Updating existing installations from 1.0.0 to release 1.0.1"},{"location":"user-guide/upgrade/#updating-your-gateways-iot-edge-module-versions","text":"Go to your solution's Azure IoT Hub and under IoT Edge, select each of your gateways. Select Set Modules and configure the two deployment modules LoRaWanNetworkSrvModule and LoRaWanPktFwdModule . Make sure, the following image URIs are configured: Deployment Module Image URI LoRaWanNetworkSrvModule loraedge/lorawannetworksrvmodule:1.0.1 LoRaWanPktFwdModule loraedge/lorawanpktfwdmodule:1.0.1","title":"Updating your gateways' IoT Edge module versions"},{"location":"user-guide/upgrade/#updating-the-azure-function-facade_6","text":"If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.1/function-1.0.1.zip Edit the Function's Application settings and make sure the FUNCTIONS_EXTENSION_VERSION App setting is set to ~2 . If during a previous upgrade you manually set it to 2.0.12342.0 , please change it back to ~2 . App Settings Name Value FUNCTIONS_EXTENSION_VERSION ~2 Make sure the IoT Hub and Redis connection strings are properly configured in the function.","title":"Updating the Azure Function Facade"},{"location":"user-guide/upgrade/#updating-existing-installations-from-040-preview-to-release-100","text":"","title":"Updating existing installations from 0.4.0-preview to release 1.0.0"},{"location":"user-guide/upgrade/#updating-the-azure-function-facade_7","text":"If you have manually deployed the Azure Function, re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. If you have deployed the solution and with it the Azure Function through the Azure Resource Manager template, you will see an App Setting in the function with the name \"WEBSITE_RUN_FROM_ZIP\". Update it's value to: https://github.com/Azure/iotedge-lorawan-starterkit/releases/download/v1.0.0/function-1.0.0.zip Edit the Function's Application settings and change the FUNCTIONS_EXTENSION_VERSION App setting from ~2 to 2.0.12342.0 App Settings Name Value FUNCTIONS_EXTENSION_VERSION 2.0.12342.0 Make sure the IoT Hub and Redis connection strings are properly configured in the function.","title":"Updating the Azure Function Facade"},{"location":"user-guide/upgrade/#updating-existing-installations-from-030-preview-to-040-preview","text":"","title":"Updating existing installations from 0.3.0-preview to 0.4.0-preview"},{"location":"user-guide/upgrade/#updating-iot-edge-runtime-containers-to-version-106","text":"We highly recommend running the latest version of the IoT Edge runtime containers on your gateway to Version 1.0.6. The way that you update the IoT Edge agent and IoT Edge hub containers depends on whether you use rolling tags (like 1.0) or specific tags (like 1.0.2) in your deployment. The process is outlined in detail here . Furthermore, make sure, the following environment variables are set for your Edge hub container: mqttSettings__enabled: false httpSettings__enabled: false TwinManagerVersion: v2 You do this by clicking \"Set Modules\" \u2192 \"Configure advanced edge runtime settings\" on your IoT Edge device in Azure IoT Hub. Make sure the DevAddr of your ABP LoRa devices starts with \"02\" : Due to addition of NetId support in this pre-relese, ABP devices created by the template prior to 0.4.0-preview (and all devices with an incompatible NetId in general) will be incompatible with the 0.4.0-preview. In this case, make sure the DevAddr of your ABP LoRa devices starts with \"02\".","title":"Updating IoT Edge Runtime Containers to Version 1.0.6"},{"location":"user-guide/upgrade/#updating-the-azure-function-facade_8","text":"Re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. Make sure the IoT Hub and Redis connection strings are properly configured in the function.","title":"Updating the Azure Function Facade"},{"location":"user-guide/upgrade/#updating-existing-installations-from-020-preview-to-030-preview","text":"","title":"Updating existing installations from 0.2.0-preview to 0.3.0-preview"},{"location":"user-guide/upgrade/#updating-iot-edge-runtime-containers-to-version-105","text":"We highly recommend running the latest version of the IoT Edge runtime containers on your gateway (Version 1.0.5 at the time of writing). The way that you update the IoT Edge agent and IoT Edge hub containers depends on whether you use rolling tags (like 1.0) or specific tags (like 1.0.2) in your deployment. The process is outlined in detail here .","title":"Updating IoT Edge Runtime Containers to Version 1.0.5"},{"location":"user-guide/upgrade/#updating-the-azure-function-facade_9","text":"Re-deploy the updated version of the Azure Function Facade as outlined here if you have a previous version of this Azure Function running. Make sure the IoT Hub and Redis connection strings are properly configured in the function.","title":"Updating the Azure Function Facade"}]}